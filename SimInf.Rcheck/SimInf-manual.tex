\nonstopmode{}
\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `SimInf'}}
\par\bigskip{\large \today}
\end{center}
\inputencoding{utf8}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdftitle = {SimInf: A Framework for Data-Driven Stochastic Disease Spread Simulations}}}{}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdfauthor = {Stefan Widgren; Robin Eriksson; Stefan Engblom; Pavol Bauer}}}{}
\begin{description}
\raggedright{}
\item[Title]\AsIs{A Framework for Data-Driven Stochastic Disease Spread
Simulations}
\item[Version]\AsIs{9.8.1.9001}
\item[Description]\AsIs{Provides an efficient and very flexible framework to
conduct data-driven epidemiological modeling in realistic large
scale disease spread simulations. The framework integrates
infection dynamics in subpopulations as continuous-time Markov
chains using the Gillespie stochastic simulation algorithm and
incorporates available data such as births, deaths and movements
as scheduled events at predefined time-points. Using C code for
the numerical solvers and 'OpenMP' (if available) to divide work
over multiple processors ensures high performance when simulating
a sample outcome. One of our design goals was to make the package
extendable and enable usage of the numerical solvers from other R
extension packages in order to facilitate complex epidemiological
research. The package contains template models and can be extended
with user-defined models. For more details see the paper by
Widgren, Bauer, Eriksson and Engblom (2019)
<}\Rhref{https://doi.org/10.18637/jss.v091.i12}{doi:10.18637/jss.v091.i12}\AsIs{>. The package also provides
functionality to fit models to time series data using the
Approximate Bayesian Computation Sequential Monte Carlo
('ABC-SMC') algorithm of Toni and others (2009)
<}\Rhref{https://doi.org/10.1098/rsif.2008.0172}{doi:10.1098/rsif.2008.0172}\AsIs{>.}
\item[Acknowledgements]\AsIs{This software has been made possible by support from
the Swedish Research Council within the UPMARC Linnaeus center
of Excellence (Pavol Bauer, Robin Eriksson, and Stefan
Engblom), the Swedish Research Council Formas (Stefan Engblom
and Stefan Widgren), the Swedish Board of Agriculture (Stefan
Widgren), the Swedish strategic research program eSSENCE
(Stefan Widgren), and in the framework of the Full Force
project, supported by funding from the European Union’s Horizon
2020 Research and Innovation programme under grant agreement No
773830: One Health European Joint Programme (Stefan Widgren).}
\item[License]\AsIs{GPL-3}
\item[URL]\AsIs{}\url{https://github.com/stewid/SimInf}\AsIs{, }\url{http://stewid.github.io/SimInf/}\AsIs{}
\item[BugReports]\AsIs{}\url{https://github.com/stewid/SimInf/issues}\AsIs{}
\item[Type]\AsIs{Package}
\item[LazyData]\AsIs{true}
\item[Biarch]\AsIs{true}
\item[NeedsCompilation]\AsIs{yes}
\item[SystemRequirements]\AsIs{GNU Scientific Library (GSL)}
\item[Depends]\AsIs{R (>= 4.0)}
\item[Imports]\AsIs{digest, graphics, grDevices, MASS, methods, mvtnorm, stats,
utils, Matrix (>= 1.3-0)}
\item[Suggests]\AsIs{knitr, rmarkdown}
\item[Collate]\AsIs{'C-generator.R' 'check_arguments.R' 'init.R' 'valid.R'
'classes.R' 'SimInf_model.R' 'SEIR.R' 'SIR.R' 'SIS.R' 'SISe.R'
'SISe3.R' 'SISe3_sp.R' 'SISe_sp.R' 'SimInf-package.R'
'SimInf.R' 'SimInf_events.R' 'SimInf_indiv_events.R' 'run.R'
'density_ratio.R' 'abc.R' 'degree.R' 'distance.R'
'distributions.R' 'edge_properties.R' 'match_compartments.R'
'mparse.R' 'pmcmc.R' 'pfilter.R' 'n.R' 'openmp.R'
'package_skeleton.R' 'plot.R' 'prevalence.R' 'print.R'
'punchcard.R' 'trajectory.R' 'u0.R' 'v0.R'}
\item[Encoding]\AsIs{UTF-8}
\item[RoxygenNote]\AsIs{7.3.2}
\item[VignetteBuilder]\AsIs{utils, knitr}
\item[Author]\AsIs{Stefan Widgren [aut, cre] (<}\url{https://orcid.org/0000-0001-5745-2284}\AsIs{>),
Robin Eriksson [aut] (<}\url{https://orcid.org/0000-0002-4291-712X}\AsIs{>),
Stefan Engblom [aut] (<}\url{https://orcid.org/0000-0002-3614-1732}\AsIs{>),
Pavol Bauer [aut] (<}\url{https://orcid.org/0000-0003-4328-7171}\AsIs{>),
Thomas Rosendal [ctb] (<}\url{https://orcid.org/0000-0002-6576-9668}\AsIs{>),
Ivana Rodriguez Ewerlöf [ctb] (<}\url{https://orcid.org/0000-0002-9678-9813}\AsIs{>),
Attractive Chaos [cph] (Author of 'kvec.h'.)}
\item[Maintainer]\AsIs{Stefan Widgren }\email{stefan.widgren@gmail.com}\AsIs{}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{abc}{Approximate Bayesian computation}{abc}
\aliasA{abc,SimInf\_model-method}{abc}{abc,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Approximate Bayesian computation
\end{Description}
%
\begin{Usage}
\begin{verbatim}
abc(
  model,
  priors = NULL,
  n_particles = NULL,
  n_init = NULL,
  distance = NULL,
  tolerance = NULL,
  data = NULL,
  verbose = getOption("verbose", FALSE),
  post_gen = NULL,
  init_model = NULL
)

## S4 method for signature 'SimInf_model'
abc(
  model,
  priors = NULL,
  n_particles = NULL,
  n_init = NULL,
  distance = NULL,
  tolerance = NULL,
  data = NULL,
  verbose = getOption("verbose", FALSE),
  post_gen = NULL,
  init_model = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{SimInf\_model} object to generate data from.

\item[\code{priors}] The priors for the parameters to fit. Each prior is
specified with a formula notation, for example, \code{beta \textasciitilde{}
uniform(0, 1)} specifies that beta is uniformly distributed
between 0 and 1. Use \code{c()} to provide more than one
prior, for example, \code{c(beta \textasciitilde{} uniform(0, 1), gamma \textasciitilde{}
normal(10, 1))}. The following distributions are supported:
\code{gamma}, \code{lognormal}, \code{normal} and
\code{uniform}. All parameters in \code{priors} must be only
in either \code{gdata} or \code{ldata}.

\item[\code{n\_particles}] An integer \code{(>1)} specifying the number of
particles to approximate the posterior with.

\item[\code{n\_init}] Specify a positive integer (>\code{n\_particles}) to
adaptively select a sequence of tolerances using the algorithm
of Simola and others (2021). The initial tolerance is
adaptively selected by sampling \code{n\_init} draws from the
prior and then retain the \code{n\_particles} particles with
the smallest distances. Note there must be enough initial
particles to satisfactorily explore the parameter space, see
Simola and others (2021). If the \code{tolerance} parameter is
specified, then \code{n\_init} must be \code{NULL}.

\item[\code{distance}] A function for calculating the summary statistics
for a simulated trajectory. For each particle, the function
must determine the distance and return that information. The
first argument, \code{result}, passed to the \code{distance}
function is the result from a \code{run} of the model with one
trajectory attached to it. The second argument,
\code{generation}, to \code{distance} is an integer with the
generation of the particle(s). Further arguments that can
passed to the \code{distance} function comes from \code{...}
in the \code{abc} function. Depending on the underlying model
structure, data for one or more particles have been generated
in each call to \code{distance}. If the \code{model} only
contains one node and all the parameters to fit are in
\code{ldata}, then that node will be replicated and each of
the replicated nodes represent one particle in the trajectory
(see `Examples'). On the other hand if the model
contains multiple nodes or the parameters to fit are contained
in \code{gdata}, then the trajectory in the \code{result}
argument represents one particle. The function can return a
numeric matrix (number of particles \eqn{\times}{} number of
summary statistics). Or, if the distance contains one summary
statistic, a numeric vector with the length equal to the
number of particles. Note that when using adaptive tolerance
selection, only one summary statistic can be used, i.e., the
function must return a matrix (number of particles
\eqn{\times}{} 1) or a numeric vector.

\item[\code{tolerance}] A numeric matrix (number of summary statistics
\eqn{\times}{} number of generations) where each column contains
the tolerances for a generation and each row contains a
sequence of gradually decreasing tolerances. Can also be a
numeric vector if there is only one summary statistic. The
tolerance determines the number of generations of ABC-SMC to
run. If the \code{n\_init} parameter is specified, then
\code{tolerance} must be \code{NULL}.

\item[\code{data}] Optional data to be passed to the \code{distance}
function. Default is \code{NULL}.

\item[\code{verbose}] prints diagnostic messages when \code{TRUE}. The
default is to retrieve the global option \code{verbose} and
use \code{FALSE} if it is not set.

\item[\code{post\_gen}] An optional function that, if non-NULL, is applied
after each completed generation. The function must accept one
argument of type \code{SimInf\_abc} with the current state of
the fitting process. This function can be useful to, for
example, save and inspect intermediate results.

\item[\code{init\_model}] An optional function that, if non-NULL, is
applied before running each proposal. The function must accept
one argument of type \code{SimInf\_model} with the current
model of the fitting process. This function can be useful to
specify the initial state of \code{u0} or \code{v0} of the
model before running a trajectory with proposed parameters.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{SimInf\_abc} object.
\end{Value}
%
\begin{References}
T. Toni, D. Welch, N. Strelkowa, A. Ipsen, and M. P. H. Stumpf. Approximate Bayesian computation scheme for parameter inference and model selection in dynamical systems. \emph{Journal of the Royal Society Interface} \strong{6}, 187--202, 2009. \Rhref{https://doi.org/10.1098/rsif.2008.0172}{doi:10.1098\slash{}rsif.2008.0172}

U. Simola, J. Cisewski-Kehe, M. U. Gutmann, J. Corander. Adaptive Approximate Bayesian Computation Tolerance Selection. \emph{Bayesian Analysis}, \strong{16}(2), 397--423, 2021. doi: 10.1214/20-BA1211
\end{References}
%
\begin{SeeAlso}
\code{\LinkA{continue\_abc}{continue.Rul.abc}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## Let us consider an SIR model in a closed population with N = 100
## individuals of whom one is initially infectious and the rest are
## susceptible. First, generate one realisation (with a specified
## seed) from the model with known parameters \code{beta = 0.16} and
## \code{gamma = 0.077}. Then, use \code{abc} to infer the (known)
## parameters from the simulated data.
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIR model and plot the number of infectious.
set.seed(22)
infectious <- trajectory(run(model), "I")$I
plot(infectious, type = "s")

## The distance function to accept or reject a proposal. Each node
## in the simulated trajectory (contained in the 'result' object)
## represents one proposal.
distance <- function(result, ...) {
    ## Extract the time-series of infectious in each node as a
    ## data.frame.
    sim <- trajectory(result, "I")

    ## Split the 'sim' data.frame by node and calculate the sum of the
    ## squared distance at each time-point for each node.
    dist <- tapply(sim$I, sim$node, function(sim_infectious) {
        sum((infectious - sim_infectious)^2)
    })

    ## Return the distance for each node. Each proposal will be
    ## accepted or rejected depending on if the distance is less than
    ## the tolerance for the current generation.
    dist
}

## Fit the model parameters using ABC-SMC and adaptive tolerance
## selection. The priors for the parameters are specified using a
## formula notation. Here we use a uniform distribtion for each
## parameter with lower bound = 0 and upper bound = 1. Note that we
## use a low number particles here to keep the run-time of the example
## short. In practice you would want to use many more to ensure better
## approximations.
fit <- abc(model = model,
           priors = c(beta ~ uniform(0, 1), gamma ~ uniform(0, 1)),
           n_particles = 100,
           n_init = 1000,
           distance = distance,
           verbose = TRUE)

## Print a brief summary.
fit

## Display the ABC posterior distribution.
plot(fit)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{as.data.frame.SimInf\_abc}{Coerce to data frame}{as.data.frame.SimInf.Rul.abc}
%
\begin{Description}
Coerce to data frame
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'SimInf_abc'
as.data.frame(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] any \R{} object.

\item[\code{...}] additional arguments to be passed to or from methods.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{as.data.frame.SimInf\_events}{Coerce events to a data frame}{as.data.frame.SimInf.Rul.events}
%
\begin{Description}
Coerce events to a data frame
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'SimInf_events'
as.data.frame(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] any \R{} object.

\item[\code{...}] additional arguments to be passed to or from methods.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{as.data.frame.SimInf\_indiv\_events}{Coerce to data frame}{as.data.frame.SimInf.Rul.indiv.Rul.events}
%
\begin{Description}
Coerce to data frame
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'SimInf_indiv_events'
as.data.frame(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] any \R{} object.

\item[\code{...}] additional arguments to be passed to or from methods.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{as.data.frame.SimInf\_pmcmc}{Coerce to data frame}{as.data.frame.SimInf.Rul.pmcmc}
%
\begin{Description}
Coerce to data frame
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'SimInf_pmcmc'
as.data.frame(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] any \R{} object.

\item[\code{...}] additional arguments to be passed to or from methods.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{boxplot,SimInf\_model-method}{Box plot of number of individuals in each compartment}{boxplot,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Produce box-and-whisker plot(s) of the number of individuals in
each model compartment.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_model'
boxplot(x, compartments = NULL, index = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The \code{model} to plot

\item[\code{compartments}] specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. \code{compartments = c('S', 'I', 'R')},
or as a formula e.g. \code{compartments = \textasciitilde{}S+I+R} (see
`Examples'). Default (\code{compartments=NULL})
includes all compartments.

\item[\code{index}] indices specifying the nodes to include when plotting
data. Default \code{index = NULL} include all nodes in the
model.

\item[\code{...}] Additional arguments affecting the plot produced.
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SIR' model with 10 nodes and initialise
## it with 99 susceptible individuals and one infected
## individual. Let the model run over 100 days.
model <- SIR(u0 = data.frame(S = rep(99, 10),
                             I = rep(1, 10),
                             R = rep(0, 10)),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the model and save the result.
result <- run(model)

## Create a boxplot that includes all compartments in all nodes.
boxplot(result)

## Create a boxplot that includes the S and I compartments in
## nodes 1 and 2.
boxplot(result, ~S+I, 1:2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{continue\_abc}{Run more generations of ABC SMC}{continue.Rul.abc}
\aliasA{continue\_abc,SimInf\_abc-method}{continue\_abc}{continue.Rul.abc,SimInf.Rul.abc.Rdash.method}
%
\begin{Description}
Run more generations of ABC SMC
\end{Description}
%
\begin{Usage}
\begin{verbatim}
continue_abc(
  object,
  tolerance = NULL,
  data = NULL,
  verbose = getOption("verbose", FALSE),
  post_gen = NULL
)

## S4 method for signature 'SimInf_abc'
continue_abc(
  object,
  tolerance = NULL,
  data = NULL,
  verbose = getOption("verbose", FALSE),
  post_gen = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_abc} object to continue from.

\item[\code{tolerance}] A numeric matrix (number of summary statistics
\eqn{\times}{} number of generations) where each column contains
the tolerances for a generation and each row contains a
sequence of gradually decreasing tolerances. Can also be a
numeric vector if there is only one summary statistic. The
tolerance determines the number of generations of ABC-SMC to
run.

\item[\code{data}] Optional data to be passed to the
\code{SimInf\_abc@fn} function. Default is \code{NULL}.

\item[\code{verbose}] prints diagnostic messages when \code{TRUE}. The
default is to retrieve the global option \code{verbose} and
use \code{FALSE} if it is not set.

\item[\code{post\_gen}] An optional function that, if non-NULL, is applied
after each completed generation. The function must accept one
argument of type \code{SimInf\_abc} with the current state of
the fitting process. This function can be useful to, for
example, save and inspect intermediate results.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{SimInf\_abc} object.
\end{Value}
\inputencoding{utf8}
\HeaderA{continue\_pmcmc}{Run more iterations of PMCMC}{continue.Rul.pmcmc}
\aliasA{continue\_pmcmc,SimInf\_pmcmc-method}{continue\_pmcmc}{continue.Rul.pmcmc,SimInf.Rul.pmcmc.Rdash.method}
%
\begin{Description}
Run more iterations of PMCMC
\end{Description}
%
\begin{Usage}
\begin{verbatim}
continue_pmcmc(
  object,
  obs_process,
  n_iterations,
  post_proposal = NULL,
  init_model = NULL,
  post_particle = NULL,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'SimInf_pmcmc'
continue_pmcmc(
  object,
  obs_process,
  n_iterations,
  post_proposal = NULL,
  init_model = NULL,
  post_particle = NULL,
  verbose = getOption("verbose", FALSE)
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_pmcmc} object to continue from.

\item[\code{obs\_process}] Specification of the stochastic observation
process. The \code{obs\_process} can be specified as a
\code{formula} if the model contains only one node and there
is only one data point for each \code{time} in \code{data}.
The left hand side of the formula must match a column name in
the \code{data} data.frame and the right hand side of the
formula is a character specifying the distribution of the
observation process, for example, \code{Iobs \textasciitilde{} poisson(I)}.
The following distributions are supported: \code{x \textasciitilde{}
binomial(size, prob)}, \code{x \textasciitilde{} poisson(rate)} and \code{x \textasciitilde{}
uniform(min, max)}. The observation process can also be a
function to evaluate the probability density of the
observations given the simulated states. The first argument
passed to the \code{obs\_process} function is the result from a
run of the model and it contains one trajectory with simulated
data for a time-point. The second argument to the
\code{obs\_process} function is a \code{data.frame} containing
the rows for the specific time-point that the function is
called for. Note that the function must return the log of the
density.

\item[\code{n\_iterations}] An integer specifying the number of iterations
to run the PMCMC.

\item[\code{post\_proposal}] An optional function that, if
non-\code{NULL}, is applied on the model after the proposal
has been set for the model, but before running the particle
filter. The function must accept one argument of type
\code{SimInf\_model} with the current model of the fitting
process. This function can be useful to update, for example,
\code{ldata} of the model before running a trajectory with
proposed parameters. The function must return the model object
which is then used in the particle filter.

\item[\code{init\_model}] An optional function that, if non-NULL, is
applied in the particle filter before running each
proposal. The function must accept one argument of type
\code{SimInf\_model} with the current model of the fitting
process. This function can be useful to specify the initial
state of \code{u0} or \code{v0} of the model before running a
trajectory with proposed parameters.

\item[\code{post\_particle}] An optional function that, if non-NULL, is
applied after each completed particle. The function must
accept three arguments: 1) an object of \code{SimInf\_pmcmc}
with the current state of the fitting process, 2) an object
\code{SimInf\_pfilter} with the last particle and one filtered
trajectory attached, and 3) an integer with the iteration in
the fitting process. This function can be useful to, for
example, monitor, save and inspect intermediate results. Note
that the second \code{SimInf\_pfilter} argument, is non-NULL
only for the first particle in the chain, and for accepted
particles.

\item[\code{verbose}] prints diagnostic messages when \code{TRUE}. The
default is to retrieve the global option \code{verbose} and
use \code{FALSE} if it is not set. When \code{verbose=TRUE},
information is printed every 100 iterations. For pmcmc, it is
possible to get information every nth information by
specifying \code{verbose=n}, for example, \code{verbose=1} or
\code{verbose=10}.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{C\_code}{Extract the C code from a \code{SimInf\_model} object}{C.Rul.code}
%
\begin{Description}
Extract the C code from a \code{SimInf\_model} object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
C_code(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{SimInf\_model} object to extract the C code
from.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Character vector with C code for the model.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Use the model parser to create a 'SimInf_model' object that
## expresses an SIR model, where 'b' is the transmission rate and
## 'g' is the recovery rate.
model <- mparse(transitions = c("S -> b*S*I/(S+I+R) -> I", "I -> g*I -> R"),
                compartments = c("S", "I", "R"),
                gdata = c(b = 0.16, g = 0.077),
                u0 = data.frame(S = 99, I = 1, R = 0),
                tspan = 1:10)

## View the C code.
C_code(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{distance\_matrix}{Create a distance matrix between nodes for spatial models}{distance.Rul.matrix}
%
\begin{Description}
Calculate the euclidian distances beween coordinates for all
coordinates within the cutoff.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
distance_matrix(x, y, cutoff, min_dist = NULL, na_fail = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Projected x coordinate

\item[\code{y}] Projected y coordinate

\item[\code{cutoff}] The distance cutoff

\item[\code{min\_dist}] The minimum distance to separate two nodes.  If
the coordinates for two nodes are identical, the min\_dist must
be assigned or an error is raised.  Default is \code{NULL},
i.e., to raise an error.

\item[\code{na\_fail}] A logical indicating whether missing values in
\code{x} or \code{y} should raise an error or assign zero to
all distances involving missing values.  Default is
\code{TRUE}, i.e., to raise an error.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{\LinkA{dgCMatrix}{dgCMatrix}}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Generate a grid 10 x 10 and place one node in each cell
## separated by 100m.
nodes <- expand.grid(x = (0:9) * 100, y = (0:9) * 100)
plot(y ~ x, nodes)

## Define the cutoff to only include neighbors within 300m.
d <- distance_matrix(x = nodes$x, y = nodes$y, cutoff = 300)

## View the first 10 rows and columns in the distance matrix
d[1:10, 1:10]
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{edge\_properties\_to\_matrix}{Convert an edge list with properties to a matrix}{edge.Rul.properties.Rul.to.Rul.matrix}
%
\begin{Description}
A utility function to facilitate preparing edge properties for
\code{ldata} in a model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
edge_properties_to_matrix(edges, n_nodes)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{edges}] a \code{data.frame} with properties assigned for each
edge 'from' --> 'to', for example, weight or count. The
\code{data.frame} must contain the columns '\code{from}' and
'\code{to}' with valid indices to the nodes (1 <= index <=
n\_nodes).

\item[\code{n\_nodes}] the total number of nodes in the model. The
resulting matrix will have the number of columns equal to
\code{n\_nodes}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The edge properties will be converted to a matrix where each row
in \code{edges} will become a sequence of (index, value\_1,
value\_2, ..., value\_n) where 'index' is the zero-based index of
the \code{from} node. The reason for a zero-based index is to
facilitate it's usage in C code. The sequence will be added to the
'to' column in the matrix. There will always be at least one stop
value=-1 in each column. All other values in the matrix will be
set to \code{NaN}. See `Examples'.
\end{Details}
%
\begin{Value}
a numeric matrix with the number of rows equal to
\code{max(table(edges\$to)) * (ncol(edges) - 1) + 1} and the
number of columns equal to \code{n\_nodes}.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Let us consider the following edge properties.
edges <- data.frame(
    from  = c(  2,    3,     4,  1,   4,    5,   1,   3,   1,   3),
    to    = c(  1,    1,     1,  2,   3,    3,   4,   4,   5,   5),
    rate  = c(0.2, 0.01,  0.79,  1, 0.2, 0.05, 0.2, 0.8, 0.2, 0.8),
    count = c(  5,    5,     5, 50,  10,   10,   5,   5,   5,   5))

## Converting the edge properties into a matrix
edge_properties_to_matrix(edges, 6)

## Gives the following output. The first column contains first the
## properties for the edge from = 2 --> to = 1, where the first
## row is the zero-based index of from, i.e., 1. The second row
## contains the rate=0.2 and the third row count=5. On the fourth
## row starts the next sequence with the values in the second row
## in the edges data.frame. The stop value in the first column is
## on row 10. As can be seen in column 6, there are no edge
## properties for node=6.
##        [,1] [,2]  [,3] [,4] [,5] [,6]
##  [1,]  1.00    0  3.00  0.0  0.0   -1
##  [2,]  0.20    1  0.20  0.2  0.2  NaN
##  [3,]  5.00   50 10.00  5.0  5.0  NaN
##  [4,]  2.00   -1  4.00  2.0  2.0  NaN
##  [5,]  0.01  NaN  0.05  0.8  0.8  NaN
##  [6,]  5.00  NaN 10.00  5.0  5.0  NaN
##  [7,]  3.00  NaN -1.00 -1.0 -1.0  NaN
##  [8,]  0.79  NaN   NaN  NaN  NaN  NaN
##  [9,]  5.00  NaN   NaN  NaN  NaN  NaN
## [10,] -1.00  NaN   NaN  NaN  NaN  NaN
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{events}{Extract the events from a \code{SimInf\_model} object}{events}
\aliasA{events,SimInf\_model-method}{events}{events,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Extract the scheduled events from a \code{SimInf\_model} object.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
events(object, ...)

## S4 method for signature 'SimInf_model'
events(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{model} to extract the events from.

\item[\code{...}] Additional arguments affecting the generated events.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}} object.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model that includes scheduled events.
model <- SIR(u0     = u0_SIR(),
             tspan  = 1:(4 * 365),
             events = events_SIR(),
             beta   = 0.16,
             gamma  = 0.077)

## Extract the scheduled events from the model and display summary
summary(events(model))

## Extract the scheduled events from the model and plot them
plot(events(model))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{events\_SEIR}{Example data to initialize events for the `SEIR' model}{events.Rul.SEIR}
%
\begin{Description}
Example data to initialize scheduled events for a population of
1600 nodes and demonstrate the \code{\LinkA{SEIR}{SEIR.Rdash.class}} model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
events_SEIR()
\end{verbatim}
\end{Usage}
%
\begin{Details}
Example data to initialize scheduled events (see
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}) for a population of 1600 nodes
and demonstrate the \code{\LinkA{SEIR}{SEIR.Rdash.class}} model. The dataset
contains 466692 events for 1600 nodes distributed over 4 * 365
days. The events are divided into three types: `Exit'
events remove individuals from the population (n = 182535),
`Enter' events add individuals to the population (n =
182685), and `External transfer' events move individuals
between nodes in the population (n = 101472). The vignette
contains a detailed description of how scheduled events operate on
a model.
\end{Details}
%
\begin{Value}
A \code{data.frame}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SEIR' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 <- u0_SEIR()
u0$I[1] <- 1
tspan <- seq(from = 1, to = 4*365, by = 1)
model <- SEIR(u0      = u0,
              tspan   = tspan,
              events  = events_SEIR(),
              beta    = 0.16,
              epsilon = 0.25,
              gamma   = 0.01)

## Display the number of individuals affected by each event type
## per day.
plot(events(model))

## Run the model to generate a single stochastic trajectory.
result <- run(model)
plot(result)

## Summarize the trajectory. The summary includes the number of
## events by event type.
summary(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{events\_SIR}{Example data to initialize events for the `SIR' model}{events.Rul.SIR}
%
\begin{Description}
Example data to initialize scheduled events for a population of
1600 nodes and demonstrate the \code{\LinkA{SIR}{SIR.Rdash.class}} model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
events_SIR()
\end{verbatim}
\end{Usage}
%
\begin{Details}
Example data to initialize scheduled events (see
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}) for a population of 1600 nodes
and demonstrate the \code{\LinkA{SIR}{SIR.Rdash.class}} model. The dataset
contains 466692 events for 1600 nodes distributed over 4 * 365
days. The events are divided into three types: `Exit'
events remove individuals from the population (n = 182535),
`Enter' events add individuals to the population (n =
182685), and `External transfer' events move individuals
between nodes in the population (n = 101472). The vignette
contains a detailed description of how scheduled events operate on
a model.
\end{Details}
%
\begin{Value}
A \code{data.frame}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 <- u0_SIR()
u0$I[1] <- 1
tspan <- seq(from = 1, to = 4*365, by = 1)
model <- SIR(u0     = u0,
             tspan  = tspan,
             events = events_SIR(),
             beta   = 0.16,
             gamma  = 0.01)

## Display the number of individuals affected by each event type
## per day.
plot(events(model))

## Run the model to generate a single stochastic trajectory.
result <- run(model)
plot(result)

## Summarize the trajectory. The summary includes the number of
## events by event type.
summary(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{events\_SIS}{Example data to initialize events for the `SIS' model}{events.Rul.SIS}
%
\begin{Description}
Example data to initialize scheduled events for a population of
1600 nodes and demonstrate the \code{\LinkA{SIS}{SIS.Rdash.class}} model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
events_SIS()
\end{verbatim}
\end{Usage}
%
\begin{Details}
Example data to initialize scheduled events (see
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}) for a population of 1600 nodes
and demonstrate the \code{\LinkA{SIS}{SIS.Rdash.class}} model. The dataset
contains 466692 events for 1600 nodes distributed over 4 * 365
days. The events are divided into three types: `Exit'
events remove individuals from the population (n = 182535),
`Enter' events add individuals to the population (n =
182685), and `External transfer' events move individuals
between nodes in the population (n = 101472). The vignette
contains a detailed description of how scheduled events operate on
a model.
\end{Details}
%
\begin{Value}
A \code{data.frame}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIS' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 <- u0_SIS()
u0$I[1] <- 1
tspan <- seq(from = 1, to = 4*365, by = 1)
model <- SIS(u0     = u0,
             tspan  = tspan,
             events = events_SIS(),
             beta   = 0.16,
             gamma  = 0.01)

## Display the number of individuals affected by each event type
## per day.
plot(events(model))

## Run the model to generate a single stochastic trajectory.
result <- run(model)
plot(result)

## Summarize the trajectory. The summary includes the number of
## events by event type.
summary(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{events\_SISe}{Example data to initialize events for the `SISe' model}{events.Rul.SISe}
%
\begin{Description}
Example data to initialize scheduled events for a population of
1600 nodes and demonstrate the \code{\LinkA{SISe}{SISe.Rdash.class}} model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
events_SISe()
\end{verbatim}
\end{Usage}
%
\begin{Details}
Example data to initialize scheduled events (see
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}) for a population of 1600 nodes
and demonstrate the \code{\LinkA{SISe}{SISe.Rdash.class}} model. The dataset
contains 466692 events for 1600 nodes distributed over 4 * 365
days. The events are divided into three types: `Exit'
events remove individuals from the population (n = 182535),
`Enter' events add individuals to the population (n =
182685), and `External transfer' events move individuals
between nodes in the population (n = 101472). The vignette
contains a detailed description of how scheduled events operate on
a model.
\end{Details}
%
\begin{Value}
A \code{data.frame}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SISe' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 <- u0_SISe()
u0$I[1] <- 1
tspan <- seq(from = 1, to = 4*365, by = 1)
model <- SISe(u0 = u0, tspan = tspan, events = events_SISe(),
              phi = 0, upsilon = 1.8e-2, gamma = 0.1, alpha = 1,
              beta_t1 = 1.0e-1, beta_t2 = 1.0e-1, beta_t3 = 1.25e-1,
              beta_t4 = 1.25e-1, end_t1 = 91, end_t2 = 182,
              end_t3 = 273, end_t4 = 365, epsilon = 0)

## Display the number of individuals affected by each event type
## per day.
plot(events(model))

## Run the model to generate a single stochastic trajectory.
result <- run(model)

## Summarize the trajectory. The summary includes the number of
## events by event type.
summary(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{events\_SISe3}{Example data to initialize events for the `SISe3' model}{events.Rul.SISe3}
\keyword{dataset}{events\_SISe3}
%
\begin{Description}
Example data to initialize scheduled events for a population of
1600 nodes and demonstrate the \code{\LinkA{SISe3}{SISe3.Rdash.class}} model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(events_SISe3)
\end{verbatim}
\end{Usage}
%
\begin{Format}
A \code{data.frame}
\end{Format}
%
\begin{Details}
Example data to initialize scheduled events (see
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}) for a population of 1600 nodes
and demonstrate the \code{\LinkA{SISe3}{SISe3.Rdash.class}} model. The dataset
contains 783773 events for 1600 nodes distributed over 4 * 365
days. The events are divided into three types: `Exit'
events remove individuals from the population (n = 182535),
`Enter' events add individuals to the population (n =
182685), `Internal transfer' events move individuals
between compartmens within one node e.g. ageing (n = 317081), and
`External transfer' events move individuals between nodes
in the population (n = 101472). The vignette contains a detailed
description of how scheduled events operate on a model.
\end{Details}
%
\begin{Examples}
\begin{ExampleCode}
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SISe3' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
data("u0_SISe3", package = "SimInf")
data("events_SISe3", package = "SimInf")
u0_SISe3$I_1[1] <- 1
tspan <- seq(from = 1, to = 4*365, by = 1)
model <- SISe3(u0 = u0_SISe3, tspan = tspan, events = events_SISe3,
               phi = rep(0, nrow(u0_SISe3)), upsilon_1 = 1.8e-2,
               upsilon_2 = 1.8e-2, upsilon_3 = 1.8e-2,
               gamma_1 = 0.1, gamma_2 = 0.1, gamma_3 = 0.1,
               alpha = 1, beta_t1 = 1.0e-1, beta_t2 = 1.0e-1,
               beta_t3 = 1.25e-1, beta_t4 = 1.25e-1, end_t1 = 91,
               end_t2 = 182, end_t3 = 273, end_t4 = 365, epsilon = 0)

## Display the number of individuals affected by each event type
## per day.
plot(events(model))

## Run the model to generate a single stochastic trajectory.
result <- run(model)

## Summarize the trajectory. The summary includes the number of
## events by event type.
summary(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{gdata}{Extract global data from a \code{SimInf\_model} object}{gdata}
\aliasA{gdata,SimInf\_model-method}{gdata}{gdata,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
The global data is a numeric vector that is common to all nodes.
The global data vector is passed as an argument to the transition
rate functions and the post time step function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
gdata(model)

## S4 method for signature 'SimInf_model'
gdata(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} to get global data from.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a numeric vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Set 'beta' to a new value
gdata(model, "beta") <- 2

## Extract the global data vector that is common to all nodes
gdata(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{gdata<-}{Set a global data parameter for a \code{SimInf\_model} object}{gdata<.Rdash.}
\aliasA{gdata<\Rdash{},SimInf\_model-method}{gdata<-}{gdata<.Rdash.,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
The global data is a numeric vector that is common to all nodes.
The global data vector is passed as an argument to the transition
rate functions and the post time step function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
gdata(model, parameter) <- value

## S4 replacement method for signature 'SimInf_model'
gdata(model, parameter) <- value
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} to set a global model parameter for.

\item[\code{parameter}] The name of the parameter to set.

\item[\code{value}] A numeric value.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a \code{SimInf\_model} object
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Set 'beta' to a new value
gdata(model, "beta") <- 2

## Extract the global data vector that is common to all nodes
gdata(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{get\_individuals}{Extract individuals from \code{SimInf\_indiv\_events}}{get.Rul.individuals}
\aliasA{get\_individuals,SimInf\_indiv\_events-method}{get\_individuals}{get.Rul.individuals,SimInf.Rul.indiv.Rul.events.Rdash.method}
%
\begin{Description}
Lookup individuals, in which node they are located and their age
at a specified time-point.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_individuals(x, time = NULL)

## S4 method for signature 'SimInf_indiv_events'
get_individuals(x, time = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] an individual events object of class
\code{SimInf\_indiv\_events}.

\item[\code{time}] the time-point for the lookup of individuals. Default
is \code{NULL} which means to extract the individuals at the
minimum time-point in the events object \code{x}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a \code{data.frame} with the columns \code{id},
\code{node}, and \code{age}.
\end{Value}
\inputencoding{utf8}
\HeaderA{indegree}{Determine in-degree for each node in a model}{indegree}
%
\begin{Description}
The number of nodes with inward \emph{external transfer} events to
each node.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
indegree(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] determine in-degree for each node in the model.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector with in-degree for each node.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SIR' model with 1600 nodes and initialize
## it with example data.
model <- SIR(u0 = u0_SIR(), tspan = 1:1460, events = events_SIR(),
             beta   = 0.16, gamma  = 0.077)

## Display indegree for each node in the model.
plot(indegree(model))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{individual\_events}{Individual events}{individual.Rul.events}
%
\begin{Description}
In many countries, individual-based livestock data are collected
to enable contact tracing during disease outbreaks. However, the
livestock databases are not always structured in such a way that
relevant information for disease spread simulations is easily
retrieved. The aim of this function is to facilitate cleaning
livestock event data and prepare it for usage in SimInf.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
individual_events(events)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{events}] a \code{data.frame} with the columns \code{id}, \code{event},
\code{time}, \code{node}, and \code{dest} to define the events, see
\code{details}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The argument \code{events} in \code{individual\_events} must be a
\code{data.frame} with the following columns:
\begin{itemize}

\item{} \strong{id:} an integer or character identifier of the individual.
\item{} \strong{event:} four event types are supported: \emph{exit},
\emph{enter}, \emph{internal transfer}, and \emph{external
transfer}.  When assigning the events, they can either be
coded as a numerical value or a character string: \emph{exit;}
\code{0} or \code{'exit'}, \emph{enter;} \code{1} or
\code{'enter'}, \emph{internal transfer;} \code{2} or
\code{'intTrans'}, and \emph{external transfer;} \code{3} or
\code{'extTrans'}.
\item{} \strong{time:} an integer, character, or date (of class \code{Date})
for when the event occured. If it's a character it must be
able to coerce to \code{Date}.
\item{} \strong{node:} an integer or character identifier of the source node.
\item{} \strong{dest:} an integer or character identifier of the destination
node for movement events, and 'dest' will be replaced with
\code{NA} for non-movement events.

\end{itemize}

\end{Details}
%
\begin{Value}
\LinkA{SimInf\_indiv\_events}{SimInf.Rul.indiv.Rul.events.Rdash.class}
\end{Value}
%
\begin{SeeAlso}
\code{\LinkA{node\_events}{node.Rul.events}}.
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{ldata}{Extract local data from a node}{ldata}
\aliasA{ldata,SimInf\_model-method}{ldata}{ldata,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
The local data is a numeric vector that is specific to a node.
The local data vector is passed as an argument to the transition
rate functions and the post time step function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ldata(model, node)

## S4 method for signature 'SimInf_model'
ldata(model, node)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} to get local data from.

\item[\code{node}] index to node to extract local data from.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a numeric vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SISe' model with 1600 nodes.
model <- SISe(u0 = u0_SISe(), tspan = 1:100, events = events_SISe(),
              phi = 0, upsilon = 1.8e-2, gamma = 0.1, alpha = 1,
              beta_t1 = 1.0e-1, beta_t2 = 1.0e-1, beta_t3 = 1.25e-1,
              beta_t4 = 1.25e-1, end_t1 = c(91, 101), end_t2 = c(182, 185),
              end_t3 = c(273, 275), end_t4 = c(365, 360), epsilon = 0)

## Display local data from the first two nodes.
ldata(model, node = 1)
ldata(model, node = 2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{length,SimInf\_pmcmc-method}{Length of the MCMC chain}{length,SimInf.Rul.pmcmc.Rdash.method}
%
\begin{Description}
Length of the MCMC chain
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pmcmc'
length(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The \code{SimInf\_pmcmc} object determine the length of
the MCMC chain for.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{logLik,SimInf\_pfilter-method}{Log likelihood}{logLik,SimInf.Rul.pfilter.Rdash.method}
%
\begin{Description}
Extract the estimated log likelihood from a \code{SimInf\_pfilter}
object.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pfilter'
logLik(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_pfilter} object.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the estimated log likelihood.
\end{Value}
\inputencoding{utf8}
\HeaderA{mparse}{Model parser to define new models to run in \code{SimInf}}{mparse}
%
\begin{Description}
Describe your model in a logical way in R. \code{mparse} creates a
\code{\LinkA{SimInf\_model}{SimInf.Rul.model.Rdash.class}} object with your model
definition that is ready to \code{\LinkA{run}{run}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mparse(
  transitions = NULL,
  compartments = NULL,
  ldata = NULL,
  gdata = NULL,
  u0 = NULL,
  v0 = NULL,
  tspan = NULL,
  events = NULL,
  E = NULL,
  N = NULL,
  pts_fun = NULL,
  use_enum = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{transitions}] character vector containing transitions on the
form \code{"X -> ... -> Y"}. The left (right) side is the
initial (final) state and the propensity is written in between
the \code{->}-signs. The special symbol \code{@} is reserved
for the empty set. For example, \code{transitions =
c("S -> beta*S*I/(S+I+R) -> I", "I -> gamma*I -> R")}
expresses the SIR model. It is also possible to define
variables which can then be used in calculations of
propensities or in calculations of other variables. A variable
is defined by the operator \code{<-}. Using a variable for the
size of the population, the SIR model can instead be written
\code{transitions = c("S -> beta*S*I/N -> I",
"I -> gamma*I -> R", "N <- S+I+R")}. By default, the type of a
variable is defined as a double in the generated C code, but
it is possible to also define it as an integer by writing
\code{(int)} before the variable name. For example, for the
SIR model, the population size can be defined as
\code{"(int)N <- S+I+R"}. It is also possible to explicitly
use (double) in front of the variable name, but it is not
needed because it is the default. Note that the order of
propensities and variables does not matter.

\item[\code{compartments}] contains the names of the involved
compartments, for example, \code{compartments = c("S", "I",
"R")}.

\item[\code{ldata}] optional data for the nodes. Can be specified as a
\code{data.frame} with one row per node, as a numeric matrix
where column \code{ldata[, j]} contains the local data vector
for the node \code{j}, or as a as a named vector when the
model only contains one node. If \code{ldata} is specified as
a \code{data.frame}, each column is one parameter. If
\code{v0} is specified as a matrix, it must have row names to
identify the parameters in the transitions. If \code{v0} is
specified as a named vector, the names identify the
parameters. The local data vector is passed as an argument to
the transition rate functions and the post time step function.

\item[\code{gdata}] optional data that are common to all nodes in the
model. Can be specified either as a optionally named numeric
vector or as as a one-row data.frame. The names are used to
identify the parameters in the transitions. When \code{gdata}
is specified as a vector, it is possible to have parameters
without names, however, these parameters will not be
automatically identified by mparse but need to be identified
in the code by the user. The global data vector is passed as
an argument to the transition rate functions and the post time
step function.

\item[\code{u0}] A \code{data.frame} with the initial state in each node,
i.e., the number of individuals in each compartment in each
node when the simulation starts (see `Details'). The
parameter \code{u0} can also be an object that can be coerced
to a \code{data.frame}, e.g., a named numeric vector will be
coerced to a one row \code{data.frame}.

\item[\code{v0}] optional data with the initial continuous state in each
node. \code{v0} can be specified as a \code{data.frame} with
one row per node, as a numeric matrix where column \code{v0[,
j]} contains the initial state vector for the node \code{j},
or as a named vector when the model only contains one node. If
\code{v0} is specified as a \code{data.frame}, each column is
one parameter. If \code{v0} is specified as a matrix, the row
names identify the parameters. If \code{v0} is specified as a
named vector, the names identify the parameters. The
`v' vector is passed as an argument to the transition
rate functions and the post time step function. The continuous
state can be updated in the post time step function.

\item[\code{tspan}] A vector (length >= 1) of increasing time points
where the state of each node is to be returned. Can be either
an \code{integer} or a \code{Date} vector. A \code{Date}
vector is coerced to a numeric vector as days, where
\code{tspan[1]} becomes the day of the year of the first year
of \code{tspan}. The dates are added as names to the numeric
vector.

\item[\code{events}] A \code{data.frame} with the scheduled
events. Default is \code{NULL} i.e. no scheduled events in the
model.

\item[\code{E}] matrix to handle scheduled events, see
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}. Default is \code{NULL}
i.e. no scheduled events in the model.

\item[\code{N}] matrix to handle scheduled events, see
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}. Default is \code{NULL}
i.e. no scheduled events in the model.

\item[\code{pts\_fun}] optional character vector with C code for the post
time step function. The C code should contain only the body of
the function i.e. the code between the opening and closing
curly brackets.

\item[\code{use\_enum}] generate enumeration constants for the indices to
each parameter in the 'u', 'v', 'ldata', and 'gdata' vectors
in the generated C code. The name of each enumeration constant
will be transformed to the upper-case name of the
corresponding parameter, for example, a parameter 'beta' will
become 'BETA'. The enumeration constants 'N\_COMPARTMENTS\_U'
and 'N\_COMPARTMENTS\_V' will be automatically added to
facilitate indexing 'u' and 'v' in the C code. These two
enumeration constants cannot be used as a compartment or
variable name. Using enumeration constants can make it easier
to modify the C code afterwards, or when writing C code for
the \code{pts\_fun} parameter. Default is \code{FALSE}, i.e.,
the parameters are specified by using integer indices for the
parameters.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a \code{\LinkA{SimInf\_model}{SimInf.Rul.model.Rdash.class}} object
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## Use the model parser to create a 'SimInf_model' object that
## expresses the SIR model, where 'beta' is the transmission rate
## and 'gamma' is the recovery rate.
model  <- mparse(transitions = c("S -> beta*S*I/N -> I",
                                 "I -> gamma*I -> R",
                                 "N <- S+I+R"),
                 compartments = c("S", "I", "R"),
                 gdata = c(beta = 0.16, gamma = 0.077),
                 u0 = data.frame(S = 100, I = 1, R = 0),
                 tspan = 1:100)

## Run and plot the result
set.seed(22)
result <- run(model)
plot(result)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{nodes}{Example data with spatial distribution of nodes}{nodes}
\keyword{dataset}{nodes}
%
\begin{Description}
Example data to initialize a population of 1600 nodes and
demonstrate various models.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(nodes)
\end{verbatim}
\end{Usage}
%
\begin{Format}
A \code{data.frame}
\end{Format}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 <- u0_SIR()
u0$I[1] <- 1
tspan <- seq(from = 1, to = 4*365, by = 1)
model <- SIR(u0     = u0,
             tspan  = tspan,
             events = events_SIR(),
             beta   = 0.16,
             gamma  = 0.077)

## Run the model to generate a single stochastic trajectory.
result <- run(model)

## Determine nodes with one or more infected individuals in the
## trajectory. Extract the 'I' compartment and check for any
## infected individuals in each node.
infected <- colSums(trajectory(result, ~ I, format = "matrix")) > 0

## Display infected nodes in 'blue' and non-infected nodes in 'yellow'.
data("nodes", package = "SimInf")
col <- ifelse(infected, "blue", "yellow")
plot(y ~ x, nodes, col = col, pch = 20, cex = 2)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{node\_events}{Transform individual events to node events for a model}{node.Rul.events}
\aliasA{node\_events,SimInf\_indiv\_events-method}{node\_events}{node.Rul.events,SimInf.Rul.indiv.Rul.events.Rdash.method}
%
\begin{Description}
In many countries, individual-based livestock data are collected
to enable contact tracing during disease outbreaks. However, the
livestock databases are not always structured in such a way that
relevant information for disease spread simulations is easily
retrieved. The aim of this function is to facilitate cleaning
livestock event data and prepare it for usage in SimInf.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
node_events(x, time = NULL, target = NULL, age = NULL)

## S4 method for signature 'SimInf_indiv_events'
node_events(x, time = NULL, target = NULL, age = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] an individual events object of class
\code{SimInf\_indiv\_events}.

\item[\code{time}] All events that occur after `time' are
included. Default is \code{NULL} which means to extract the
events after the minimum time-point in the
\code{SimInf\_indiv\_events} object.

\item[\code{target}] The SimInf model ('SEIR', 'SIR', 'SIS', 'SISe3',
'SISe3\_sp', 'SISe', or 'SISe\_sp') to target the events and u0
for. The default, \code{NULL}, creates events but they might
have to be post-processed to fit the specific use case.

\item[\code{age}] Integer vector with break points in days for the ageing
events.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The individual-based events will be aggregated on node-level.  The
\code{select} value is determined by the event type and age
category.  If there is only one age category, i.e.,
\code{age=NULL}, then \code{select=1} for the enter events, and
\code{select=2} for all other events. If there are two age
categories, then \code{select=1} for the enter events in the first
age category, and \code{select=2} for the enter events in the
second age category. Similarly, \code{select=3} for all other
events in the first age category, and \code{select=4} for all
other events in the first second category. With three age
categories, it works similarly with \code{select=1,2,3} for the
enter events in each age category, respectively. And
\code{select=4,5,6} for all other events.
\end{Details}
%
\begin{Value}
a \code{data.frame} with the columns \code{event},
\code{time}, \code{node}, \code{dest}, \code{n},
\code{proportion}, \code{select}, and \code{shift}.
\end{Value}
%
\begin{SeeAlso}
\code{\LinkA{individual\_events}{individual.Rul.events}}.
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{n\_compartments}{Determine the number of compartments in a model}{n.Rul.compartments}
\aliasA{n\_compartments,SimInf\_model-method}{n\_compartments}{n.Rul.compartments,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Determine the number of compartments in a model
\end{Description}
%
\begin{Usage}
\begin{verbatim}
n_compartments(model)

## S4 method for signature 'SimInf_model'
n_compartments(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] the \code{model} object to extract the number of
compartments from.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the number of compartments in the model.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SIR' model with 100 nodes, with 99 susceptible,
## 1 infected and 0 recovered in each node.
u0 <- data.frame(S = rep(99, 100), I = rep(1, 100), R = rep(0, 100))
model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)

## Display the number of compartments in the model.
n_compartments(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{n\_generations}{Determine the number of generations}{n.Rul.generations}
\aliasA{n\_generations,SimInf\_abc-method}{n\_generations}{n.Rul.generations,SimInf.Rul.abc.Rdash.method}
%
\begin{Description}
Determine the number of generations
\end{Description}
%
\begin{Usage}
\begin{verbatim}
n_generations(object)

## S4 method for signature 'SimInf_abc'
n_generations(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] the \code{SimInf\_abc} object to determine the number
of generations for.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
an integer with the number of generations.
\end{Value}
\inputencoding{utf8}
\HeaderA{n\_nodes}{Determine the number of nodes in a model}{n.Rul.nodes}
\aliasA{n\_nodes,SimInf\_model-method}{n\_nodes}{n.Rul.nodes,SimInf.Rul.model.Rdash.method}
\aliasA{n\_nodes,SimInf\_pfilter-method}{n\_nodes}{n.Rul.nodes,SimInf.Rul.pfilter.Rdash.method}
\aliasA{n\_nodes,SimInf\_pmcmc-method}{n\_nodes}{n.Rul.nodes,SimInf.Rul.pmcmc.Rdash.method}
%
\begin{Description}
Determine the number of nodes in a model
\end{Description}
%
\begin{Usage}
\begin{verbatim}
n_nodes(model)

## S4 method for signature 'SimInf_model'
n_nodes(model)

## S4 method for signature 'SimInf_pfilter'
n_nodes(model)

## S4 method for signature 'SimInf_pmcmc'
n_nodes(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] the \code{model} object to extract the number of
nodes from.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the number of nodes in the model.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SIR' model with 100 nodes, with 99 susceptible,
## 1 infected and 0 recovered in each node.
u0 <- data.frame(S = rep(99, 100), I = rep(1, 100), R = rep(0, 100))
model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)

## Display the number of nodes in the model.
n_nodes(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{n\_replicates}{Determine the number of replicates in a model}{n.Rul.replicates}
\aliasA{n\_replicates,SimInf\_model-method}{n\_replicates}{n.Rul.replicates,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Determine the number of replicates in a model
\end{Description}
%
\begin{Usage}
\begin{verbatim}
n_replicates(model)

## S4 method for signature 'SimInf_model'
n_replicates(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] the \code{model} object to extract the number of
replicates from.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the number of replicates in the model.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SIR' model with 100 nodes, with 99 susceptible,
## 1 infected and 0 recovered in each node.
u0 <- data.frame(S = rep(99, 100), I = rep(1, 100), R = rep(0, 100))
model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)

## Display the number of replicates in the model.
n_replicates(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{outdegree}{Determine out-degree for each node in a model}{outdegree}
%
\begin{Description}
The number nodes that are connected with \emph{external transfer}
events from each node.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
outdegree(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] determine out-degree for each node in the model.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector with out-degree for each node.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SIR' model with 1600 nodes and initialize
## it with example data.
model <- SIR(u0 = u0_SIR(), tspan = 1:1460, events = events_SIR(),
             beta   = 0.16, gamma  = 0.077)

## Display outdegree for each node in the model.
plot(outdegree(model))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{package\_skeleton}{Create a package skeleton from a \code{SimInf\_model}}{package.Rul.skeleton}
%
\begin{Description}
Describe your model in a logical way in R, then \code{mparse}
creates a \code{\LinkA{SimInf\_model}{SimInf.Rul.model.Rdash.class}} object with your model
definition that can be installed as an add-on R package.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
package_skeleton(
  model,
  name = NULL,
  path = ".",
  author = NULL,
  email = NULL,
  maintainer = NULL,
  license = "GPL-3"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} \code{\LinkA{SimInf\_model}{SimInf.Rul.model.Rdash.class}}
object with your model to create the package skeleton from.

\item[\code{name}] Character string with the package name. It should
contain only (ASCII) letters, numbers and dot, have at least
two characters and start with a letter and not end in a dot.
The package name is also used for the class name of the model
and the directory name of the package.

\item[\code{path}] Path to put the package directory in. Default is '.'
i.e. the current directory.

\item[\code{author}] Author of the package.

\item[\code{email}] Email of the package maintainer.

\item[\code{maintainer}] Maintainer of the package.

\item[\code{license}] License of the package. Default is 'GPL-3'.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
invisible \code{NULL}.
\end{Value}
%
\begin{References}
Read the \emph{Writing R Extensions} manual for more
details.

Once you have created a \emph{source} package you need to install
it: see the \emph{R Installation and Administration} manual,
\code{\LinkA{INSTALL}{INSTALL}} and \code{\LinkA{install.packages}{install.packages}}.
\end{References}
\inputencoding{utf8}
\HeaderA{pairs,SimInf\_model-method}{Scatterplot of number of individuals in each compartment}{pairs,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
A matrix of scatterplots with the number of individuals in each
compartment is produced. The \code{ij}th scatterplot contains
\code{x[,i]} plotted against \code{x[,j]}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_model'
pairs(x, compartments = NULL, index = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The \code{model} to plot

\item[\code{compartments}] specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. \code{compartments = c('S', 'I', 'R')},
or as a formula e.g. \code{compartments = \textasciitilde{}S+I+R} (see
`Examples'). Default (\code{compartments=NULL})
includes all compartments.

\item[\code{index}] indices specifying the nodes to include when plotting
data. Default \code{index = NULL} include all nodes in the
model.

\item[\code{...}] Additional arguments affecting the plot produced.
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 10 nodes and initialise
## it with 99 susceptible individuals and one infected
## individual. Let the model run over 100 days.
model <- SIR(u0 = data.frame(S = rep(99, 10),
                             I = rep(1, 10),
                             R = rep(0, 10)),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the model and save the result.
result <- run(model)

## Create a scatter plot that includes all compartments in all
## nodes.
pairs(result)

## Create a scatter plot that includes the S and I compartments in
## nodes 1 and 2.
pairs(result, ~S+I, 1:2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{pfilter}{Bootstrap particle filter}{pfilter}
\aliasA{pfilter,SimInf\_model-method}{pfilter}{pfilter,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
The bootstrap filtering algorithm. Systematic resampling is
performed at each observation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pfilter(model, obs_process, data, n_particles, init_model = NULL)

## S4 method for signature 'SimInf_model'
pfilter(model, obs_process, data, n_particles, init_model = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{SimInf\_model} object to simulate data from.

\item[\code{obs\_process}] Specification of the stochastic observation
process. The \code{obs\_process} can be specified as a
\code{formula} if the model contains only one node and there
is only one data point for each \code{time} in \code{data}.
The left hand side of the formula must match a column name in
the \code{data} data.frame and the right hand side of the
formula is a character specifying the distribution of the
observation process, for example, \code{Iobs \textasciitilde{} poisson(I)}.
The following distributions are supported: \code{x \textasciitilde{}
binomial(size, prob)}, \code{x \textasciitilde{} poisson(rate)} and \code{x \textasciitilde{}
uniform(min, max)}. The observation process can also be a
function to evaluate the probability density of the
observations given the simulated states. The first argument
passed to the \code{obs\_process} function is the result from a
run of the model and it contains one trajectory with simulated
data for a time-point. The second argument to the
\code{obs\_process} function is a \code{data.frame} containing
the rows for the specific time-point that the function is
called for. Note that the function must return the log of the
density.

\item[\code{data}] A \code{data.frame} holding the time series data.

\item[\code{n\_particles}] An integer with the number of particles (> 1)
to use at each timestep.

\item[\code{init\_model}] An optional function that, if non-NULL, is
applied before running each proposal. The function must accept
one argument of type \code{SimInf\_model} with the current
model of the fitting process. This function can be useful to
specify the initial state of \code{u0} or \code{v0} of the
model before running a trajectory with proposed parameters.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{SimInf\_pfilter} object.
\end{Value}
%
\begin{References}
N. J. Gordon, D. J. Salmond, and A. F. M. Smith. Novel Approach to Nonlinear/Non-Gaussian Bayesian State Estimation. \emph{Radar and Signal Processing, IEE Proceedings F}, \strong{140}(2) 107--113, 1993. \Rhref{https://doi.org/10.1049/ip-f-2.1993.0015}{doi:10.1049\slash{}ip\-f\-2.1993.0015}
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## Let us consider an SIR model in a closed population with N = 100
## individuals of whom one is initially infectious and the rest are
## susceptible. First, generate one realisation (with a specified
## seed) from the model with known parameters 'beta = 0.16' and
## 'gamma = 0.077'. Then, use 'pfilter' to apply the bootstrap
## particle algorithm on the simulated data.
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = seq(1, 100, by = 3),
             beta = 0.16,
             gamma = 0.077)

## Run the SIR model to generate simulated observed data for the
## number of infected individuals.
set.seed(22)
infected <- trajectory(run(model), "I")[, c("time", "I")]
colnames(infected) <- c("time", "Iobs")

## Use a Poison observation process for the infected individuals, such
## that 'Iobs ~ poison(I + 1e-6)'. A small constant '1e-6' is added to
## prevent numerical errors, since the simulated counts 'I' could be
## zero, which would result in the Poisson rate parameter being zero,
## which violates the conditions of the Poisson distribution. Use 1000
## particles.
pf <- pfilter(model,
              obs_process = Iobs ~ poisson(I + 1e-6),
              data = infected,
              n_particles = 1000)

## Print a brief summary.
pf

## Compare the number infected 'I' in the filtered trajectory with the
## infected 'Iobs' in the observed data.
plot(pf, ~I)
lines(Iobs ~ time, infected, col = "blue", lwd = 2, type = "s")

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plot,SimInf\_abc-method}{Display the ABC posterior distribution}{plot,SimInf.Rul.abc.Rdash.method}
%
\begin{Description}
Display the ABC posterior distribution
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_abc'
plot(x, y, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The \code{SimInf\_abc} object to plot.

\item[\code{y}] The generation to plot. The default is to display the
last generation.

\item[\code{...}] Additional arguments affecting the plot.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{plot,SimInf\_events-method}{Display the distribution of scheduled events over time}{plot,SimInf.Rul.events.Rdash.method}
%
\begin{Description}
Display the distribution of scheduled events over time
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_events'
plot(x, frame.plot = FALSE, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The events data to plot.

\item[\code{frame.plot}] Draw a frame around each plot. Default is FALSE.

\item[\code{...}] Additional arguments affecting the plot
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{plot,SimInf\_indiv\_events-method}{Display the distribution of individual events over time}{plot,SimInf.Rul.indiv.Rul.events.Rdash.method}
%
\begin{Description}
Display the distribution of individual events over time
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_indiv_events'
plot(x, frame.plot = FALSE, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The individual events data to plot.

\item[\code{frame.plot}] a logical indicating whether a box should be
drawn around the plot.

\item[\code{...}] Other graphical parameters that are passed on to the
plot function.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{plot,SimInf\_model-method}{Display the outcome from a simulated trajectory}{plot,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Plot either the median and the quantile range of the counts in all
nodes, or plot the counts in specified nodes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_model'
plot(
  x,
  y,
  level = 1,
  index = NULL,
  range = 0.5,
  type = "s",
  lwd = 2,
  frame.plot = FALSE,
  legend = TRUE,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The \code{model} to plot.

\item[\code{y}] Character vector or formula with the compartments in the
model to include in the plot. Default includes all
compartments in the model. Can also be a formula that
specifies the compartments that define the cases with a
disease or that have a specific characteristic (numerator),
and the compartments that define the entire population of
interest (denominator). The left-hand-side of the formula
defines the cases, and the right-hand-side defines the
population, for example, \code{I\textasciitilde{}S+I+R} in a `SIR'
model (see `Examples'). The \code{.}  (dot) is expanded
to all compartments, for example, \code{I\textasciitilde{}.}  is expanded to
\code{I\textasciitilde{}S+I+R} in a `SIR' model (see
`Examples').

\item[\code{level}] The level at which the prevalence is calculated at
each time point in \code{tspan}. 1 (population prevalence):
calculates the proportion of the individuals (cases) in the
population. 2 (node prevalence): calculates the proportion of
nodes with at least one case. 3 (within-node prevalence):
calculates the proportion of cases within each node. Default
is \code{1}.

\item[\code{index}] Indices specifying the nodes to include when plotting
data. Plot one line for each node. Default (\code{index =
NULL}) is to extract data from all nodes and plot the median
count for the specified compartments.

\item[\code{range}] Show the quantile range of the count in each
compartment. Default is to show the interquartile range
i.e. the middle 50\% of the count in transparent color. The
median value is shown in the same color. Use \code{range =
0.95} to show the middle 95\% of the count. To display
individual lines for each node, specify \code{range = FALSE}.

\item[\code{type}] The type of plot to draw. The default \code{type =
"s"} draws stair steps. See base plot for other values.

\item[\code{lwd}] The line width. Default is \code{2}.

\item[\code{frame.plot}] a logical indicating whether a box should be
drawn around the plot.

\item[\code{legend}] a logical indicating whether a legend for the
compartments should be added to the plot. A legend is not
drawn for a prevalence plot.

\item[\code{...}] Other graphical parameters that are passed on to the
plot function.
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 100 nodes and initialise
## it with 990 susceptible individuals and 10 infected
## individuals in each node. Run the model over 100 days.
model <- SIR(u0 = data.frame(S = rep(990, 100),
                             I = rep(10, 100),
                             R = rep(0, 100)),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the model and save the result.
result <- run(model)

## Plot the median and interquartile range of the number
## of susceptible, infected and recovered individuals.
plot(result)

## Plot the median and the middle 95\
## number of susceptible, infected and recovered individuals.
plot(result, range = 0.95)

## Plot the median and interquartile range of the  number
## of infected individuals.
plot(result, "I")

## Use the formula notation instead to plot the median and
## interquartile range of the number of infected individuals.
plot(result, ~I)

## Plot the number of susceptible, infected
## and recovered individuals in the first
## three nodes.
plot(result, index = 1:3, range = FALSE)

## Use plot type line instead.
plot(result, index = 1:3, range = FALSE, type = "l")

## Plot the number of infected individuals in the first node.
plot(result, "I", index = 1, range = FALSE)

## Plot the proportion of infected individuals (cases)
## in the population.
plot(result, I ~ S + I + R)

## Plot the proportion of nodes with infected individuals.
plot(result, I ~ S + I + R, level = 2)

## Plot the median and interquartile range of the proportion
## of infected individuals in each node
plot(result, I ~ S + I + R, level = 3)

## Plot the proportion of infected individuals in the first
## three nodes.
plot(result, I ~ S + I + R, level = 3, index = 1:3, range = FALSE)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plot,SimInf\_pfilter-method}{Diagnostic plot of a particle filter object}{plot,SimInf.Rul.pfilter.Rdash.method}
%
\begin{Description}
Diagnostic plot of a particle filter object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pfilter'
plot(x, y, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The \code{SimInf\_pfilter} object to plot.

\item[\code{y}] If y is \code{NULL} or missing (default), the filtered
trajectory (top) and the effective sample size (bottom) are
displayed. If \code{y} is a character vector or a formula, the
plot function for a \code{SimInf\_model} object is called with
the filtered trajectory, see
\code{\LinkA{plot,SimInf\_model-method}{plot,SimInf.Rul.model.Rdash.method}} for more details about
the specification a plot.

\item[\code{...}] Other graphical parameters that are passed on to the
plot function.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{plot,SimInf\_pmcmc-method}{Display the PMCMC posterior distribution}{plot,SimInf.Rul.pmcmc.Rdash.method}
%
\begin{Description}
Display the (approximate) posterior distributions obtained from
fitting a particle Markov chain Monte Carlo algorithm, or the
corresponding trace plots.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pmcmc'
plot(x, y, start = 1, end = NULL, thin = 1, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The \code{SimInf\_pmcmc} object to plot.

\item[\code{y}] The trace of all variables and logPost are plotted when
\code{y = "trace"} or \code{y = \textasciitilde{}trace}, else the posterior
distributions are plotted. Default is to plot the posterier
distributions.

\item[\code{start}] The start iteration to remove some burn-in
iterations. Default is \code{start = 1}.

\item[\code{end}] the last iteration to include. Default is \code{NULL}
which set \code{end} to the last iteration in the chain.

\item[\code{thin}] keep every \code{thin} iteration after the
\code{start} iteration. Default is \code{thin = 1}, i.e., keep
every iteration.

\item[\code{...}] Additional arguments affecting the plot.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{pmcmc}{Particle Markov chain Monte Carlo (PMCMC) algorithm}{pmcmc}
\aliasA{pmcmc,SimInf\_model-method}{pmcmc}{pmcmc,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Particle Markov chain Monte Carlo (PMCMC) algorithm
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pmcmc(
  model,
  obs_process,
  data,
  priors,
  n_particles,
  n_iterations,
  theta = NULL,
  covmat = NULL,
  adaptmix = 0.05,
  adaptive = 100,
  post_proposal = NULL,
  init_model = NULL,
  post_particle = NULL,
  chain = NULL,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'SimInf_model'
pmcmc(
  model,
  obs_process,
  data,
  priors,
  n_particles,
  n_iterations,
  theta = NULL,
  covmat = NULL,
  adaptmix = 0.05,
  adaptive = 100,
  post_proposal = NULL,
  init_model = NULL,
  post_particle = NULL,
  chain = NULL,
  verbose = getOption("verbose", FALSE)
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The model to simulate data from.

\item[\code{obs\_process}] Specification of the stochastic observation
process. The \code{obs\_process} can be specified as a
\code{formula} if the model contains only one node and there
is only one data point for each \code{time} in \code{data}.
The left hand side of the formula must match a column name in
the \code{data} data.frame and the right hand side of the
formula is a character specifying the distribution of the
observation process, for example, \code{Iobs \textasciitilde{} poisson(I)}.
The following distributions are supported: \code{x \textasciitilde{}
binomial(size, prob)}, \code{x \textasciitilde{} poisson(rate)} and \code{x \textasciitilde{}
uniform(min, max)}. The observation process can also be a
function to evaluate the probability density of the
observations given the simulated states. The first argument
passed to the \code{obs\_process} function is the result from a
run of the model and it contains one trajectory with simulated
data for a time-point. The second argument to the
\code{obs\_process} function is a \code{data.frame} containing
the rows for the specific time-point that the function is
called for. Note that the function must return the log of the
density.

\item[\code{data}] A \code{data.frame} holding the time series data.

\item[\code{priors}] The priors for the parameters to fit. Each prior is
specified with a formula notation, for example, \code{beta \textasciitilde{}
uniform(0, 1)} specifies that beta is uniformly distributed
between 0 and 1. Use \code{c()} to provide more than one
prior, for example, \code{c(beta \textasciitilde{} uniform(0, 1), gamma \textasciitilde{}
normal(10, 1))}. The following distributions are supported:
\code{gamma}, \code{lognormal}, \code{normal} and
\code{uniform}. All parameters in \code{priors} must be only
in either \code{gdata} or \code{ldata}.

\item[\code{n\_particles}] An integer with the number of particles (> 1)
to use at each timestep.

\item[\code{n\_iterations}] An integer specifying the number of iterations
to run the PMCMC.

\item[\code{theta}] A named vector of initial values for the parameters
of the model.  Default is \code{NULL}, and then these are
sampled from the prior distribution(s).

\item[\code{covmat}] A named numeric \code{(npars x npars)} matrix with
covariances to use as initial proposal matrix. If left
unspecified then defaults to \code{diag((theta/10)\textasciicircum{}2/npars)}.

\item[\code{adaptmix}] Mixing proportion for adaptive proposal.  Must be
a value between zero and one. Default is \code{adaptmix =
0.05}.

\item[\code{adaptive}] Controls when to start adaptive update. Must be
greater or equal to zero. If \code{adaptive=0}, then adaptive
update is not performed. Default is \code{adaptive = 100}.

\item[\code{post\_proposal}] An optional function that, if
non-\code{NULL}, is applied on the model after the proposal
has been set for the model, but before running the particle
filter. The function must accept one argument of type
\code{SimInf\_model} with the current model of the fitting
process. This function can be useful to update, for example,
\code{ldata} of the model before running a trajectory with
proposed parameters. The function must return the model object
which is then used in the particle filter.

\item[\code{init\_model}] An optional function that, if non-NULL, is
applied in the particle filter before running each
proposal. The function must accept one argument of type
\code{SimInf\_model} with the current model of the fitting
process. This function can be useful to specify the initial
state of \code{u0} or \code{v0} of the model before running a
trajectory with proposed parameters.

\item[\code{post\_particle}] An optional function that, if non-NULL, is
applied after each completed particle. The function must
accept three arguments: 1) an object of \code{SimInf\_pmcmc}
with the current state of the fitting process, 2) an object
\code{SimInf\_pfilter} with the last particle and one filtered
trajectory attached, and 3) an integer with the iteration in
the fitting process. This function can be useful to, for
example, monitor, save and inspect intermediate results. Note
that the second \code{SimInf\_pfilter} argument, is non-NULL
only for the first particle in the chain, and for accepted
particles.

\item[\code{chain}] An optional chain to start from. Must be a
\code{data.frame} or an object that can be coerced to a
\code{data.frame}. Only the columns in \code{chain} with a
name that matches the names that will be used if this argument
is not provided will be used. When this argument is provided,
\code{n\_iterations} can be 0.

\item[\code{verbose}] prints diagnostic messages when \code{TRUE}. The
default is to retrieve the global option \code{verbose} and
use \code{FALSE} if it is not set. When \code{verbose=TRUE},
information is printed every 100 iterations. For pmcmc, it is
possible to get information every nth information by
specifying \code{verbose=n}, for example, \code{verbose=1} or
\code{verbose=10}.
\end{ldescription}
\end{Arguments}
%
\begin{References}
C. Andrieu, A. Doucet and R. Holenstein. Particle Markov chain Monte Carlo methods. \emph{Journal of the Royal Statistical Society, Series B} \strong{72}, 269--342, 2010. \Rhref{https://doi.org/10.1111/j.1467-9868.2009.00736.x}{doi:10.1111\slash{}j.1467\-9868.2009.00736.x}

G. O. Roberts and J. S. Rosenthal. Examples of adaptive MCMC. \emph{Journal of computational and graphical statistics}, \strong{18}(2), 349--367, 2009. \Rhref{https://doi.org/10.1198/jcgs.2009.06134}{doi:10.1198\slash{}jcgs.2009.06134}
\end{References}
%
\begin{SeeAlso}
\code{\LinkA{continue\_pmcmc}{continue.Rul.pmcmc}}.
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{prevalence}{Generic function to calculate prevalence from trajectory data}{prevalence}
%
\begin{Description}
Calculate the proportion of individuals with disease in the
population, or the proportion of nodes with at least one diseased
individual, or the proportion of individuals with disease in each
node.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
prevalence(model, formula, level = 1, index = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} with trajectory data to calculate
the prevalence from.

\item[\code{formula}] A formula that specifies the compartments that
define the cases with a disease or that have a specific
characteristic (numerator), and the compartments that define
the entire population of interest (denominator). The
left-hand-side of the formula defines the cases, and the
right-hand-side defines the population, for example,
\code{I\textasciitilde{}S+I+R} in a `SIR' model (see
`Examples'). The \code{.}  (dot) is expanded to all
compartments, for example, \code{I\textasciitilde{}.}  is expanded to
\code{I\textasciitilde{}S+I+R} in a `SIR' model (see
`Examples'). The formula can also contain a condition
(indicated by \code{|}) for each node and time step to further
control the population to include in the calculation, for
example, \code{I \textasciitilde{} . | R == 0} to calculate the prevalence
when the recovered is zero in a `SIR' model. The
condition must evaluate to \code{TRUE} or \code{FALSE} in each
node and time step. Please note, if the denominator is zero,
the prevalence is \code{NaN}. Additionally, when
\code{level=3} (within-node prevalence) and the formula
contains a condition that evaluates to \code{FALSE}, the
prevalence is also \code{NaN}.

\item[\code{level}] The level at which the prevalence is calculated at
each time point in \code{tspan}. 1 (population prevalence):
calculates the proportion of the individuals (cases) in the
population. 2 (node prevalence): calculates the proportion of
nodes with at least one case. 3 (within-node prevalence):
calculates the proportion of cases within each node. Default
is \code{1}.

\item[\code{index}] indices specifying the subset of nodes to include
when extracting data. Default (\code{index = NULL}) is to
extract data from all nodes.

\item[\code{...}] Additional arguments, see
\code{\LinkA{prevalence,SimInf\_model-method}{prevalence,SimInf.Rul.model.Rdash.method}}
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{prevalence,SimInf\_model-method}{Calculate prevalence from a model object with trajectory data}{prevalence,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Calculate the proportion of individuals with disease in the
population, or the proportion of nodes with at least one diseased
individual, or the proportion of individuals with disease in each
node.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_model'
prevalence(model, formula, level, index, format = c("data.frame", "matrix"))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} with trajectory data to calculate
the prevalence from.

\item[\code{formula}] A formula that specifies the compartments that
define the cases with a disease or that have a specific
characteristic (numerator), and the compartments that define
the entire population of interest (denominator). The
left-hand-side of the formula defines the cases, and the
right-hand-side defines the population, for example,
\code{I\textasciitilde{}S+I+R} in a `SIR' model (see
`Examples'). The \code{.}  (dot) is expanded to all
compartments, for example, \code{I\textasciitilde{}.}  is expanded to
\code{I\textasciitilde{}S+I+R} in a `SIR' model (see
`Examples'). The formula can also contain a condition
(indicated by \code{|}) for each node and time step to further
control the population to include in the calculation, for
example, \code{I \textasciitilde{} . | R == 0} to calculate the prevalence
when the recovered is zero in a `SIR' model. The
condition must evaluate to \code{TRUE} or \code{FALSE} in each
node and time step. Please note, if the denominator is zero,
the prevalence is \code{NaN}. Additionally, when
\code{level=3} (within-node prevalence) and the formula
contains a condition that evaluates to \code{FALSE}, the
prevalence is also \code{NaN}.

\item[\code{level}] The level at which the prevalence is calculated at
each time point in \code{tspan}. 1 (population prevalence):
calculates the proportion of the individuals (cases) in the
population. 2 (node prevalence): calculates the proportion of
nodes with at least one case. 3 (within-node prevalence):
calculates the proportion of cases within each node. Default
is \code{1}.

\item[\code{index}] indices specifying the subset of nodes to include
when extracting data. Default (\code{index = NULL}) is to
extract data from all nodes.

\item[\code{format}] The default (\code{format = "data.frame"}) is to
generate a \code{data.frame} with one row per time-step with
the prevalence. Using \code{format = "matrix"} returns the
result as a matrix.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{data.frame} if \code{format = "data.frame"}, else
a matrix.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SIR' model with 6 nodes and initialize
## it to run over 10 days.
u0 <- data.frame(S = 100:105, I = c(0, 1, 0, 2, 0, 3), R = rep(0, 6))
model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)

## Run the model to generate a single stochastic trajectory.
result <- run(model)

## Determine the proportion of infected individuals (cases)
## in the population at the time-points in 'tspan'.
prevalence(result, I ~ S + I + R)

## Identical result is obtained with the shorthand 'I~.'
prevalence(result, I ~ .)

## Determine the proportion of nodes with infected individuals at
## the time-points in 'tspan'.
prevalence(result, I ~ S + I + R, level = 2)

## Determine the proportion of infected individuals in each node
## at the time-points in 'tspan'.
prevalence(result, I ~ S + I + R, level = 3)

## Determine the proportion of infected individuals in each node
## at the time-points in 'tspan' when the number of recovered is
## zero.
prevalence(result, I ~ S + I + R | R == 0, level = 3)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{prevalence,SimInf\_pfilter-method}{Extract prevalence from running a particle filter}{prevalence,SimInf.Rul.pfilter.Rdash.method}
%
\begin{Description}
Extract prevalence from running a particle filter
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pfilter'
prevalence(model, formula, level, index, format = c("data.frame", "matrix"))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] the \code{SimInf\_pfilter} object to extract the
prevalence from.

\item[\code{formula}] A formula that specifies the compartments that
define the cases with a disease or that have a specific
characteristic (numerator), and the compartments that define
the entire population of interest (denominator). The
left-hand-side of the formula defines the cases, and the
right-hand-side defines the population, for example,
\code{I\textasciitilde{}S+I+R} in a `SIR' model (see
`Examples'). The \code{.}  (dot) is expanded to all
compartments, for example, \code{I\textasciitilde{}.}  is expanded to
\code{I\textasciitilde{}S+I+R} in a `SIR' model (see
`Examples'). The formula can also contain a condition
(indicated by \code{|}) for each node and time step to further
control the population to include in the calculation, for
example, \code{I \textasciitilde{} . | R == 0} to calculate the prevalence
when the recovered is zero in a `SIR' model. The
condition must evaluate to \code{TRUE} or \code{FALSE} in each
node and time step. Please note, if the denominator is zero,
the prevalence is \code{NaN}. Additionally, when
\code{level=3} (within-node prevalence) and the formula
contains a condition that evaluates to \code{FALSE}, the
prevalence is also \code{NaN}.

\item[\code{level}] The level at which the prevalence is calculated at
each time point in \code{tspan}. 1 (population prevalence):
calculates the proportion of the individuals (cases) in the
population. 2 (node prevalence): calculates the proportion of
nodes with at least one case. 3 (within-node prevalence):
calculates the proportion of cases within each node. Default
is \code{1}.

\item[\code{index}] indices specifying the subset of nodes to include
when extracting data. Default (\code{index = NULL}) is to
extract data from all nodes.

\item[\code{format}] The default (\code{format = "data.frame"}) is to
generate a \code{data.frame} with one row per time-step with
the prevalence. Using \code{format = "matrix"} returns the
result as a matrix.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{data.frame} if \code{format = "data.frame"}, else
a matrix.
\end{Value}
\inputencoding{utf8}
\HeaderA{prevalence,SimInf\_pmcmc-method}{Extract prevalence from fitting a PMCMC algorithm}{prevalence,SimInf.Rul.pmcmc.Rdash.method}
%
\begin{Description}
Extract prevalence from the filtered trajectories from a particle
Markov chain Monte Carlo algorithm.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pmcmc'
prevalence(model, formula, level, index, start = 1, end = NULL, thin = 1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] the \code{SimInf\_pmcmc} object to extract the
prevalence from.

\item[\code{formula}] A formula that specifies the compartments that
define the cases with a disease or that have a specific
characteristic (numerator), and the compartments that define
the entire population of interest (denominator). The
left-hand-side of the formula defines the cases, and the
right-hand-side defines the population, for example,
\code{I\textasciitilde{}S+I+R} in a `SIR' model (see
`Examples'). The \code{.}  (dot) is expanded to all
compartments, for example, \code{I\textasciitilde{}.}  is expanded to
\code{I\textasciitilde{}S+I+R} in a `SIR' model (see
`Examples'). The formula can also contain a condition
(indicated by \code{|}) for each node and time step to further
control the population to include in the calculation, for
example, \code{I \textasciitilde{} . | R == 0} to calculate the prevalence
when the recovered is zero in a `SIR' model. The
condition must evaluate to \code{TRUE} or \code{FALSE} in each
node and time step. Please note, if the denominator is zero,
the prevalence is \code{NaN}. Additionally, when
\code{level=3} (within-node prevalence) and the formula
contains a condition that evaluates to \code{FALSE}, the
prevalence is also \code{NaN}.

\item[\code{level}] The level at which the prevalence is calculated at
each time point in \code{tspan}. 1 (population prevalence):
calculates the proportion of the individuals (cases) in the
population. 2 (node prevalence): calculates the proportion of
nodes with at least one case. 3 (within-node prevalence):
calculates the proportion of cases within each node. Default
is \code{1}.

\item[\code{index}] indices specifying the subset of nodes to include
when extracting data. Default (\code{index = NULL}) is to
extract data from all nodes.

\item[\code{start}] The start iteration to remove some burn-in
iterations. Default is \code{start = 1}.

\item[\code{end}] the last iteration to include. Default is \code{NULL}
which set \code{end} to the last iteration in the chain.

\item[\code{thin}] keep every \code{thin} iteration after the
\code{start} iteration. Default is \code{thin = 1}, i.e., keep
every iteration.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{data.frame} where the first column is the
\code{iteration} and the remaining columns are the result from
calling \code{\LinkA{prevalence,SimInf\_model-method}{prevalence,SimInf.Rul.model.Rdash.method}} with the
arguments \code{formula}, \code{level} and \code{index} for
each iteration.
\end{Value}
\inputencoding{utf8}
\HeaderA{punchcard<-}{Set a template for where to record result during a simulation}{punchcard<.Rdash.}
\aliasA{punchcard<\Rdash{},SimInf\_model-method}{punchcard<-}{punchcard<.Rdash.,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Using a sparse result matrix can save a lot of memory if the model
contains many nodes and time-points, but where only a few of the
data points are of interest for post-processing.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
punchcard(model) <- value

## S4 replacement method for signature 'SimInf_model'
punchcard(model) <- value
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} to set a template for where to
record result.

\item[\code{value}] A \code{data.frame} that specify the nodes,
time-points and compartments to record the number of
individuals at \code{tspan}. Use \code{NULL} to reset the
model to record the number of inidividuals in each compartment
in every node at each time-point in tspan.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
Using a sparse result matrix can save a lot of memory if the model
contains many nodes and time-points, but where only a few of the
data points are of interest for post-processing. To use this
feature, a template has to be defined for which data points to
record. This is done using a \code{data.frame} that specifies the
time-points (column `time') and nodes (column
`node') to record the state of the compartments, see
`Examples'. The specified time-points, nodes and
compartments must exist in the model, or an error is raised. Note
that specifying a template only affects which data-points are
recorded for post-processing, it does not affect how the solver
simulates the trajectory.
\end{Details}
%
\begin{Examples}
\begin{ExampleCode}
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 6 nodes and initialize it to run over 10 days.
u0 <- data.frame(S = 100:105, I = 1:6, R = rep(0, 6))
model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)

## Run the model.
result <- run(model)

## Display the trajectory with data for every node at each
## time-point in tspan.
trajectory(result)

## Assume we are only interested in nodes '2' and '4' at the
## time-points '3' and '5'
df <- data.frame(time = c(3, 5, 3, 5),
                 node = c(2, 2, 4, 4),
                 S = c(TRUE, TRUE, TRUE, TRUE),
                 I = c(TRUE, TRUE, TRUE, TRUE),
                 R = c(TRUE, TRUE, TRUE, TRUE))
punchcard(model) <- df
result <- run(model)
trajectory(result)

## We can also specify to record only some of the compartments in
## each time-step.
df <- data.frame(time = c(3, 5, 3, 5),
                 node = c(2, 2, 4, 4),
                 S = c(FALSE, TRUE, TRUE, TRUE),
                 I = c(TRUE, FALSE, TRUE, FALSE),
                 R = c(TRUE, FALSE, TRUE, TRUE))
punchcard(model) <- df
result <- run(model)
trajectory(result)

## A shortcut to specify to record all of the compartments in
## each time-step is to only inlude node and time.
df <- data.frame(time = c(3, 5, 3, 5),
                 node = c(2, 2, 4, 4))
punchcard(model) <- df
result <- run(model)
trajectory(result)

## It is possible to use an empty 'data.frame' to specify
## that no data-points should be recorded for the trajectory.
punchcard(model) <- data.frame()
result <- run(model)
trajectory(result)

## Use 'NULL' to reset the model to record data for every node at
## each time-point in tspan.
punchcard(model) <- NULL
result <- run(model)
trajectory(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{run}{Run the SimInf stochastic simulation algorithm}{run}
\aliasA{run,SEIR-method}{run}{run,SEIR.Rdash.method}
\aliasA{run,SimInf\_abc-method}{run}{run,SimInf.Rul.abc.Rdash.method}
\aliasA{run,SimInf\_model-method}{run}{run,SimInf.Rul.model.Rdash.method}
\aliasA{run,SIR-method}{run}{run,SIR.Rdash.method}
\aliasA{run,SIS-method}{run}{run,SIS.Rdash.method}
\aliasA{run,SISe-method}{run}{run,SISe.Rdash.method}
\aliasA{run,SISe3-method}{run}{run,SISe3.Rdash.method}
\aliasA{run,SISe3\_sp-method}{run}{run,SISe3.Rul.sp.Rdash.method}
\aliasA{run,SISe\_sp-method}{run}{run,SISe.Rul.sp.Rdash.method}
%
\begin{Description}
Run the SimInf stochastic simulation algorithm
\end{Description}
%
\begin{Usage}
\begin{verbatim}
run(model, ...)

## S4 method for signature 'SimInf_model'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SEIR'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SIR'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SIS'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SISe'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SISe3'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SISe3_sp'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SISe_sp'
run(model, solver = c("ssm", "aem"), ...)

## S4 method for signature 'SimInf_abc'
run(model, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The SimInf model to run.

\item[\code{...}] Additional arguments.

\item[\code{solver}] Which numerical solver to utilize. Default is 'ssm'.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{\LinkA{SimInf\_model}{SimInf.Rul.model}} object with result from
simulation.
\end{Value}
%
\begin{References}
S. Widgren, P. Bauer, R. Eriksson and S. Engblom. \pkg{SimInf}: An \textsf{R} Package for Data-Driven Stochastic Disease Spread Simulations. \emph{Journal of Statistical Software}, \strong{91}(12), 1--42. \Rhref{https://doi.org/10.18637/jss.v091.i12}{doi:10.18637\slash{}jss.v091.i12}. An updated version of this paper is available as a vignette in the package.

P. Bauer, S. Engblom and S. Widgren. Fast Event-Based Epidemiological Simulations on National Scales. \emph{International Journal of High Performance Computing Applications}, \strong{30}(4), 438--453, 2016. doi: 10.1177/1094342016635723

P. Bauer and S. Engblom. Sensitivity Estimation and Inverse Problems in Spatial Stochastic Models of Chemical Kinetics. In: A. Abdulle, S. Deparis, D. Kressner, F. Nobile and M. Picasso (eds.), \emph{Numerical Mathematics and Advanced Applications - ENUMATH 2013}, pp. 519--527, Lecture Notes in Computational Science and Engineering, vol 103. Springer, Cham, 2015. \Rhref{https://doi.org/10.1007/978-3-319-10705-9_51}{doi:10.1007\slash{}978\-3\-319\-10705\-9\_51}
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 10 nodes and initialise
## it to run over 100 days.
model <- SIR(u0 = data.frame(S = rep(99, 10),
                             I = rep(1, 10),
                             R = rep(0, 10)),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the model and save the result.
result <- run(model)

## Plot the proportion of susceptible, infected and recovered
## individuals.
plot(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SEIR}{Create an \acronym{SEIR} model}{SEIR}
%
\begin{Description}
Create an \acronym{SEIR} model to be used by the simulation
framework.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SEIR(u0, tspan, events = NULL, beta = NULL, epsilon = NULL, gamma = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{u0}] A \code{data.frame} with the initial state in each node,
i.e., the number of individuals in each compartment in each
node when the simulation starts (see `Details'). The
parameter \code{u0} can also be an object that can be coerced
to a \code{data.frame}, e.g., a named numeric vector will be
coerced to a one row \code{data.frame}.

\item[\code{tspan}] A vector (length >= 1) of increasing time points
where the state of each node is to be returned. Can be either
an \code{integer} or a \code{Date} vector. A \code{Date}
vector is coerced to a numeric vector as days, where
\code{tspan[1]} becomes the day of the year of the first year
of \code{tspan}. The dates are added as names to the numeric
vector.

\item[\code{events}] a \code{data.frame} with the scheduled events, see
\code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.

\item[\code{beta}] A numeric vector with the transmission rate from
susceptible to infected where each node can have a different
beta value. The vector must have length 1 or \code{nrow(u0)}.
If the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.

\item[\code{epsilon}] A numeric vector with the incubation rate from
exposed to infected where each node can have a different
epsilon value. The vector must have length 1 or
\code{nrow(u0)}.  If the vector has length 1, but the model
contains more nodes, the epsilon value is repeated in all
nodes.

\item[\code{gamma}] A numeric vector with the recovery rate from infected
to recovered where each node can have a different gamma
value. The vector must have length 1 or \code{nrow(u0)}. If
the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The \acronym{SEIR} model contains four compartments; number of
susceptible (S), number of exposed (E) (those who have been
infected but are not yet infectious), number of infectious (I),
and number of recovered (R).  Moreover, it has three state
transitions,

\deqn{S \stackrel{\beta S I / N}{\longrightarrow} E}{}
\deqn{E \stackrel{\epsilon E}{\longrightarrow} I}{}
\deqn{I \stackrel{\gamma I}{\longrightarrow} R}{}

where \eqn{\beta}{} is the transmission rate, \eqn{\epsilon}{} is the
incubation rate, \eqn{\gamma}{} is the recovery rate, and
\eqn{N=S+E+I+R}{}.

The argument \code{u0} must be a \code{data.frame} with one row for
each node with the following columns:
\begin{description}

\item[S] The number of sucsceptible in each node
\item[E] The number of exposed in each node
\item[I] The number of infected in each node
\item[R] The number of recovered in each node

\end{description}

\end{Details}
%
\begin{Value}
A \code{\LinkA{SimInf\_model}{SimInf.Rul.model}} of class \code{SEIR}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create a SEIR model object.
model <- SEIR(u0 = data.frame(S = 99, E = 0, I = 1, R = 0),
              tspan = 1:100,
              beta = 0.16,
              epsilon = 0.25,
              gamma = 0.077)

## Run the SEIR model and plot the result.
set.seed(3)
result <- run(model)
plot(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SEIR-class}{Definition of the `SEIR' model}{SEIR.Rdash.class}
%
\begin{Description}
Class to handle the SEIR \code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.
\end{Description}
\inputencoding{utf8}
\HeaderA{select\_matrix}{Extract the select matrix from a \code{SimInf\_model} object}{select.Rul.matrix}
\aliasA{select\_matrix,SimInf\_model-method}{select\_matrix}{select.Rul.matrix,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Utility function to extract \code{events@E} from a
\code{SimInf\_model} object, see \code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
select_matrix(model)

## S4 method for signature 'SimInf_model'
select_matrix(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} to extract the select matrix
\code{E} from.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{\LinkA{dgCMatrix}{dgCMatrix}} object.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Extract the select matrix from the model
select_matrix(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{select\_matrix<-}{Set the select matrix for a \code{SimInf\_model} object}{select.Rul.matrix<.Rdash.}
\aliasA{select\_matrix<\Rdash{},SimInf\_model-method}{select\_matrix<-}{select.Rul.matrix<.Rdash.,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Utility function to set \code{events@E} in a \code{SimInf\_model}
object, see \code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
select_matrix(model) <- value

## S4 replacement method for signature 'SimInf_model'
select_matrix(model) <- value
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} to set the select matrix for.

\item[\code{value}] A matrix.
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Set the select matrix
select_matrix(model) <- matrix(c(1, 0, 0, 1, 1, 1, 0, 0, 1), nrow = 3)

## Extract the select matrix from the model
select_matrix(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{set\_num\_threads}{Specify the number of threads that SimInf should use}{set.Rul.num.Rul.threads}
%
\begin{Description}
Set the number of threads to be used in SimInf code that is
parallelized with OpenMP (if available). The number of threads is
initialized when SimInf is first loaded in the R session using
optional envioronment variables (see `Details'). It is also
possible to specify the number of threads by calling
\code{set\_num\_threads}. If the environment variables that affect
the number of threads change, then \code{set\_num\_threads} must be
called again for it to take effect.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_num_threads(threads = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{threads}] integer with maximum number of threads to use in
functions that are parallelized with OpenMP (if
available). Default is NULL, i.e. to use all available
processors and then check for limits in the environment
varibles (see `Details').
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The \code{omp\_get\_num\_procs()} function is used to determine the
number of processors that are available to the device at the time
the routine is called. The number of threads is then limited by
\code{omp\_get\_thread\_limit()} and the current values of the
environmental variables (if set)

\begin{itemize}

\item{} \code{Sys.getenv("OMP\_THREAD\_LIMIT")}
\item{} \code{Sys.getenv("OMP\_NUM\_THREADS")}
\item{} \code{Sys.getenv("SIMINF\_NUM\_THREADS")}

\end{itemize}


Additionally, the maximum number of threads can be controlled by
the \code{threads} argument, given that its value is not above any
of the limits described above.
\end{Details}
%
\begin{Value}
The previous value is returned (invisible).
\end{Value}
\inputencoding{utf8}
\HeaderA{shift\_matrix}{Extract the shift matrix from a \code{SimInf\_model} object}{shift.Rul.matrix}
\aliasA{shift\_matrix,SimInf\_model-method}{shift\_matrix}{shift.Rul.matrix,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Utility function to extract the shift matrix \code{events@N} from
a \code{SimInf\_model} object, see
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shift_matrix(model)

## S4 method for signature 'SimInf_model'
shift_matrix(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} to extract the shift matrix
\code{events@N} from.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A mtrix.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Extract the shift matrix from the model
shift_matrix(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{shift\_matrix<-}{Set the shift matrix for a \code{SimInf\_model} object}{shift.Rul.matrix<.Rdash.}
\aliasA{shift\_matrix<\Rdash{},SimInf\_model-method}{shift\_matrix<-}{shift.Rul.matrix<.Rdash.,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Utility function to set \code{events@N} in a \code{SimInf\_model}
object, see \code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shift_matrix(model) <- value

## S4 replacement method for signature 'SimInf_model'
shift_matrix(model) <- value
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The \code{model} to set the shift matrix
\code{events@N}.

\item[\code{value}] A matrix.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{SimInf\_model} object
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:5, beta = 0.16, gamma = 0.077)

## Set the shift matrix
shift_matrix(model) <- matrix(c(2, 1, 0), nrow = 3)

## Extract the shift matrix from the model
shift_matrix(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{show,SimInf\_abc-method}{Print summary of a \code{SimInf\_abc} object}{show,SimInf.Rul.abc.Rdash.method}
%
\begin{Description}
Print summary of a \code{SimInf\_abc} object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_abc'
show(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_abc} object.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{invisible(object)}.
\end{Value}
\inputencoding{utf8}
\HeaderA{show,SimInf\_events-method}{Brief summary of \code{SimInf\_events}}{show,SimInf.Rul.events.Rdash.method}
%
\begin{Description}
Shows the number of scheduled events.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_events'
show(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The SimInf\_events \code{object}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
None (invisible 'NULL').
\end{Value}
\inputencoding{utf8}
\HeaderA{show,SimInf\_indiv\_events-method}{Print summary of a \code{SimInf\_indiv\_events} object}{show,SimInf.Rul.indiv.Rul.events.Rdash.method}
%
\begin{Description}
Print summary of a \code{SimInf\_indiv\_events} object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_indiv_events'
show(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_indiv\_events} object.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{invisible(object)}.
\end{Value}
\inputencoding{utf8}
\HeaderA{show,SimInf\_model-method}{Brief summary of \code{SimInf\_model}}{show,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Brief summary of \code{SimInf\_model}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_model'
show(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The SimInf\_model \code{object}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
None (invisible 'NULL').
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SIR' model with 10 nodes and initialise
## it to run over 100 days.
model <- SIR(u0 = data.frame(S = rep(99, 10),
                             I = rep(1, 10),
                             R = rep(0, 10)),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Brief summary of the model
model

## Run the model and save the result
result <- run(model)

## Brief summary of the result. Note that 'U' and 'V' are
## non-empty after running the model.
result
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{show,SimInf\_pfilter-method}{Brief summary of a \code{SimInf\_pfilter} object}{show,SimInf.Rul.pfilter.Rdash.method}
%
\begin{Description}
Brief summary of a \code{SimInf\_pfilter} object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pfilter'
show(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_pfilter} object.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{invisible(object)}.
\end{Value}
\inputencoding{utf8}
\HeaderA{show,SimInf\_pmcmc-method}{Brief summary of a \code{SimInf\_pmcmc} object}{show,SimInf.Rul.pmcmc.Rdash.method}
%
\begin{Description}
Brief summary of a \code{SimInf\_pmcmc} object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pmcmc'
show(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_pmcmc} object.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{invisible(object)}.
\end{Value}
\inputencoding{utf8}
\HeaderA{SimInf}{A Framework for Data-Driven Stochastic Disease Spread Simulations}{SimInf}
\aliasA{SimInf-package}{SimInf}{SimInf.Rdash.package}
%
\begin{Description}
The SimInf package provides a flexible framework for data-driven
spatio-temporal disease spread modeling, designed to efficiently
handle population demographics and network data. The framework
integrates infection dynamics in each subpopulation as
continuous-time Markov chains (CTMC) using the Gillespie
stochastic simulation algorithm (SSA) and incorporates available
data such as births, deaths or movements as scheduled events. A
scheduled event is used to modify the state of a subpopulation at
a predefined time-point.
\end{Description}
%
\begin{Details}
The \code{\LinkA{SimInf\_model}{SimInf.Rul.model.Rdash.class}} is central and provides the
basis for the framework. A \code{\LinkA{SimInf\_model}{SimInf.Rul.model.Rdash.class}}
object supplies the state-change matrix, the dependency graph, the
scheduled events, and the initial state of the system.

All predefined models in SimInf have a generating function, with
the same name as the model, for example \code{\LinkA{SIR}{SIR}}.

A model can also be created from a model specification using the
\code{\LinkA{mparse}{mparse}} method.

After a model is created, a simulation is started with a call to
the \code{\LinkA{run}{run}} method and if execution is successful, it
returns a modified \code{\LinkA{SimInf\_model}{SimInf.Rul.model.Rdash.class}} object with a
single stochastic solution trajectory attached to it.

SimInf provides several utility functions to inspect simulated
data, for example, \code{show}, \code{summary} and \code{plot}.
To facilitate custom analysis, it provides the
\code{\LinkA{trajectory,SimInf\_model-method}{trajectory,SimInf.Rul.model.Rdash.method}} and
\code{\LinkA{prevalence}{prevalence}} methods.

One of our design goal was to make SimInf extendable and enable
usage of the numerical solvers from other R extension packages in
order to facilitate complex epidemiological research.  To support
this, SimInf has functionality to generate the required C and R
code from a model specification, see
\code{\LinkA{package\_skeleton}{package.Rul.skeleton}}
\end{Details}
%
\begin{Author}
\strong{Maintainer}: Stefan Widgren \email{stefan.widgren@gmail.com} (\Rhref{https://orcid.org/0000-0001-5745-2284}{ORCID})

Authors:
\begin{itemize}

\item{} Robin Eriksson (\Rhref{https://orcid.org/0000-0002-4291-712X}{ORCID})
\item{} Stefan Engblom (\Rhref{https://orcid.org/0000-0002-3614-1732}{ORCID})
\item{} Pavol Bauer (\Rhref{https://orcid.org/0000-0003-4328-7171}{ORCID})

\end{itemize}


Other contributors:
\begin{itemize}

\item{} Thomas Rosendal (\Rhref{https://orcid.org/0000-0002-6576-9668}{ORCID}) [contributor]
\item{} Ivana Rodriguez Ewerlöf (\Rhref{https://orcid.org/0000-0002-9678-9813}{ORCID}) [contributor]
\item{} Attractive Chaos (Author of 'kvec.h'.) [copyright holder]

\end{itemize}


\end{Author}
%
\begin{References}
S. Widgren, P. Bauer, R. Eriksson and S. Engblom. \pkg{SimInf}: An \textsf{R} Package for Data-Driven Stochastic Disease Spread Simulations. \emph{Journal of Statistical Software}, \strong{91}(12), 1--42. \Rhref{https://doi.org/10.18637/jss.v091.i12}{doi:10.18637\slash{}jss.v091.i12}. An updated version of this paper is available as a vignette in the package.
\end{References}
%
\begin{SeeAlso}
Useful links:
\begin{itemize}

\item{} \url{https://github.com/stewid/SimInf}
\item{} \url{http://stewid.github.io/SimInf/}
\item{} Report bugs at \url{https://github.com/stewid/SimInf/issues}

\end{itemize}


\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{SimInf\_abc-class}{Class \code{"SimInf\_abc"}}{SimInf.Rul.abc.Rdash.class}
%
\begin{Description}
Class \code{"SimInf\_abc"}
\end{Description}
%
\begin{Section}{Slots}

\begin{description}

\item[\code{model}] The \code{SimInf\_model} object to estimate parameters
in.

\item[\code{priors}] A \code{data.frame} containing the four columns
\code{parameter}, \code{distribution}, \code{p1} and
\code{p2}. The column \code{parameter} gives the name of the
parameter referred to in the model. The column
\code{distribution} contains the name of the prior
distribution. Valid distributions are 'gamma', 'normal' or
'uniform'. The column \code{p1} is a numeric vector with the
first hyperparameter for each prior: 'gamma') shape,
'lognormal') logmean, 'normal') mean, and 'uniform') lower
bound. The column \code{p2} is a numeric vector with the
second hyperparameter for each prior: 'gamma') rate,
'lognormal') standard deviation on the log scale, 'normal')
standard deviation, and 'uniform') upper bound.

\item[\code{target}] Character vector (\code{gdata} or \code{ldata}) that
determines if the ABC-SMC method estimates parameters in
\code{model@gdata} or in \code{model@ldata}.

\item[\code{pars}] Index to the parameters in \code{target}.

\item[\code{nprop}] An integer vector with the number of simulated
proposals in each generation.

\item[\code{fn}] A function for calculating the summary statistics for the
simulated trajectory and determine the distance for each
particle, see \code{\LinkA{abc}{abc}} for more details.

\item[\code{tolerance}] A numeric matrix (number of summary statistics
\eqn{\times}{} number of generations) where each column contains
the tolerances for a generation and each row contains a
sequence of gradually decreasing tolerances.

\item[\code{x}] A numeric array (number of particles \eqn{\times}{} number
of parameters \eqn{\times}{} number of generations) with the
parameter values for the accepted particles in each
generation. Each row is one particle.

\item[\code{weight}] A numeric matrix (number of particles \eqn{\times}{}
number of generations) with the weights for the particles
\code{x} in the corresponding generation.

\item[\code{distance}] A numeric array (number of particles \eqn{\times}{}
number of summary statistics \eqn{\times}{} number of
generations) with the distance for the particles \code{x} in
each generation. Each row contains the distance for a particle
and each column contains the distance for a summary statistic.

\item[\code{ess}] A numeric vector with the effective sample size (ESS) in
each generation. The effective sample size is computed as
\deqn{\left(\sum_{i=1}^N\!(w_{g}^{(i)})^2\right)^{-1},}{} where \eqn{w_{g}^{(i)}}{} is the
normalized weight of particle \eqn{i}{} in generation \eqn{g}{}.

\item[\code{init\_model}] An optional function that, if non-NULL, is
applied before running each proposal. The function must accept
one argument of type \code{SimInf\_model} with the current
model of the fitting process. This function can be useful to
specify the initial state of \code{u0} or \code{v0} of the
model before running a trajectory with proposed parameters.

\end{description}
\end{Section}
%
\begin{SeeAlso}
\code{\LinkA{abc}{abc}} and \code{\LinkA{continue\_abc}{continue.Rul.abc}}.
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{SimInf\_events}{Create a \code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}} object}{SimInf.Rul.events}
%
\begin{Description}
The argument events must be a \code{data.frame} with the following
columns:
\begin{description}

\item[event] 
Four event types are supported by the current solvers:
\emph{exit}, \emph{enter}, \emph{internal transfer}, and
\emph{external transfer}.  When assigning the events, they can
either be coded as a numerical value or a character string:
\emph{exit;} \code{0} or \code{'exit'}, \emph{enter;} \code{1}
or \code{'enter'}, \emph{internal transfer;} \code{2} or
\code{'intTrans'}, and \emph{external transfer;} \code{3} or
\code{'extTrans'}.  Internally in \pkg{SimInf}, the event type
is coded as a numerical value.

\item[time] 
When the event occurs i.e., the event is processed when time
is reached in the simulation. Can be either an \code{integer}
or a \code{Date} vector.  A \code{Date} vector is coerced to a
numeric vector as days, where \code{t0} determines the offset
to match the time of the events to the model \code{tspan}
vector.

\item[node] 
The node that the event operates on. Also the source node for
an \emph{external transfer} event.
1 <= \code{node[i]} <= Number of nodes.

\item[dest] 
The destination node for an \emph{external transfer} event
i.e., individuals are moved from \code{node} to \code{dest},
where 1 <= \code{dest[i]} <= Number of nodes.  Set \code{event
    = 0} for the other event types.  \code{dest} is an integer
vector.

\item[n] 
The number of individuals affected by the event. n[i] >= 0.

\item[proportion] 
If \code{n[i]} equals zero, the number of individuals affected
by \code{event[i]} is calculated by sampling the number of
individuals from a binomial distribution using the
\code{proportion[i]} and the number of individuals in the
compartments. Numeric vector.  0 <= proportion[i] <= 1.

\item[select] 
To process an \code{event[i]}, the compartments affected by
the event are specified with \code{select[i]} together with
the matrix \code{E}, where \code{select[i]} determines which
column in \code{E} to use.  The specific individuals affected
by the event are sampled from the compartments corresponding
to the non-zero entries in the specified column in \code{E[,
    select[i]]}, where \code{select} is an integer vector.

\item[shift] 
Determines how individuals in \emph{internal transfer} and
\emph{external transfer} events are shifted to enter another
compartment.  The sampled individuals are shifted according to
column \code{shift[i]} in matrix \code{N} i.e., \code{N[,
    shift[i]]}, where \code{shift} is an integer vector.  See
above for a description of \code{N}. Unsued for the other
event types.


\end{description}

\end{Description}
%
\begin{Usage}
\begin{verbatim}
SimInf_events(E = NULL, N = NULL, events = NULL, t0 = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{E}] Each row corresponds to one compartment in the model. The
non-zero entries in a column indicates the compartments to
include in an event.  For the \emph{exit}, \emph{internal
transfer} and \emph{external transfer} events, a non-zero
entry indicate the compartments to sample individuals from.
For the \emph{enter} event, all individuals enter first
non-zero compartment. \code{E} is sparse matrix of class
\code{\LinkA{dgCMatrix}{dgCMatrix}}.

\item[\code{N}] Determines how individuals in \emph{internal transfer}
and \emph{external transfer} events are shifted to enter
another compartment.  Each row corresponds to one compartment
in the model.  The values in a column are added to the current
compartment of sampled individuals to specify the destination
compartment, for example, a value of \code{1} in an entry
means that sampled individuals in this compartment are moved
to the next compartment.  Which column to use for each event
is specified by the \code{shift} vector (see below).  \code{N}
is an integer matrix.

\item[\code{events}] A \code{data.frame} with events.

\item[\code{t0}] If \code{events\$time} is a \code{Date} vector, then
\code{t0} determines the offset to match the time of the
events to the model \code{tspan} vector, see details. If
\code{events\$time} is a numeric vector, then \code{t0} must be
\code{NULL}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
S4 class \code{SimInf\_events}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Let us illustrate how movement events can be used to transfer
## individuals from one node to another.  Use the built-in SIR
## model and start with 2 nodes where all individuals are in the
## first node (100 per compartment).
u0 <- data.frame(S = c(100, 0), I = c(100, 0), R = c(100, 0))

## Then create 300 movement events to transfer all individuals,
## one per day, from the first node to the second node. Use the
## fourth column in the select matrix where all compartments
## can be sampled with equal weight.
events <- data.frame(event      = rep("extTrans", 300),
                     time       = 1:300,
                     node       = 1,
                     dest       = 2,
                     n          = 1,
                     proportion = 0,
                     select     = 4,
                     shift      = 0)

## Create an SIR model without disease transmission to
## demonstrate the events.
model <- SIR(u0      = u0,
             tspan  = 1:300,
             events = events,
             beta   = 0,
             gamma  = 0)

## Run the model and plot the number of individuals in
## the second node.  As can be seen in the figure, all
## indivuduals have been moved to the second node when
## t = 300.
plot(run(model), index = 1:2, range = FALSE)

## Let us now double the weight to sample from the 'I'
## compartment and rerun the model.
model@events@E[2, 4] <- 2
plot(run(model), index = 1:2, range = FALSE)

## And much larger weight to sample from the I compartment.
model@events@E[2, 4] <- 10
plot(run(model), index = 1:2, range = FALSE)

## Increase the weight for the R compartment.
model@events@E[3, 4] <- 4
plot(run(model), index = 1:2, range = FALSE)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SimInf\_events-class}{Class \code{"SimInf\_events"}}{SimInf.Rul.events.Rdash.class}
%
\begin{Description}
Class to hold data for scheduled events to modify the discrete
state of individuals in a node at a pre-defined time t.
\end{Description}
%
\begin{Section}{Slots}

\begin{description}

\item[\code{E}] Each row corresponds to one compartment in the model. The
non-zero entries in a column indicates the compartments to
include in an event.  For the \emph{exit}, \emph{internal
transfer} and \emph{external transfer} events, a non-zero
entry indicate the compartments to sample individuals from.
For the \emph{enter} event, all individuals enter first
non-zero compartment. \code{E} is sparse matrix of class
\code{\LinkA{dgCMatrix}{dgCMatrix}}.

\item[\code{N}] Determines how individuals in \emph{internal transfer} and
\emph{external transfer} events are shifted to enter another
compartment.  Each row corresponds to one compartment in the
model.  The values in a column are added to the current
compartment of sampled individuals to specify the destination
compartment, for example, a value of \code{1} in an entry
means that sampled individuals in this compartment are moved
to the next compartment.  Which column to use for each event
is specified by the \code{shift} vector (see below).  \code{N}
is an integer matrix.

\item[\code{event}] Type of event: 0) \emph{exit}, 1) \emph{enter}, 2)
\emph{internal transfer}, and 3) \emph{external transfer}.
Other values are reserved for future event types and not
supported by the current solvers. Integer vector.

\item[\code{time}] Time of when the event occurs i.e., the event is
processed when time is reached in the simulation.  \code{time}
is an integer vector.

\item[\code{node}] The node that the event operates on. Also the source
node for an \emph{external transfer} event.  Integer vector.
1 <= \code{node[i]} <= Number of nodes.

\item[\code{dest}] The destination node for an \emph{external transfer}
event i.e., individuals are moved from \code{node} to
\code{dest}, where 1 <= \code{dest[i]} <= Number of nodes.
Set \code{event = 0} for the other event types.  \code{dest}
is an integer vector.

\item[\code{n}] The number of individuals affected by the event. Integer
vector.  n[i] >= 0.

\item[\code{proportion}] If \code{n[i]} equals zero, the number of
individuals affected by \code{event[i]} is calculated by
sampling the number of individuals from a binomial
distribution using the \code{proportion[i]} and the number of
individuals in the compartments. Numeric vector.  0 <=
proportion[i] <= 1.

\item[\code{select}] To process \code{event[i]}, the compartments affected
by the event are specified with \code{select[i]} together with
the matrix \code{E}, where \code{select[i]} determines which
column in \code{E} to use.  The specific individuals affected
by the event are proportionally sampled from the compartments
corresponding to the non-zero entries in the specified column
in \code{E[, select[i]]}, where \code{select} is an integer
vector.

\item[\code{shift}] Determines how individuals in \emph{internal transfer}
and \emph{external transfer} events are shifted to enter
another compartment.  The sampled individuals are shifted
according to column \code{shift[i]} in matrix \code{N} i.e.,
\code{N[, shift[i]]}, where \code{shift} is an integer vector.
See above for a description of \code{N}. Unsued for the other
event types.

\end{description}
\end{Section}
\inputencoding{utf8}
\HeaderA{SimInf\_indiv\_events-class}{Class \code{"SimInf\_indiv\_events"}}{SimInf.Rul.indiv.Rul.events.Rdash.class}
%
\begin{Description}
Class \code{"SimInf\_indiv\_events"}
\end{Description}
%
\begin{Section}{Slots}

\begin{description}

\item[\code{id}] an integer or character identifier of the individual.

\item[\code{event}] four event types are supported: \emph{exit},
\emph{enter}, \emph{internal transfer}, and \emph{external
transfer}.  When assigning the events, they can either be
coded as a numerical value or a character string: \emph{exit;}
\code{0} or \code{'exit'}, \emph{enter;} \code{1} or
\code{'enter'}, \emph{internal transfer;} \code{2} or
\code{'intTrans'}, and \emph{external transfer;} \code{3} or
\code{'extTrans'}.

\item[\code{time}] an integer, character, or date (of class \code{Date})
for when the event occured. If it's a character it must be
able to coerce to \code{Date}.

\item[\code{node}] an integer or character identifier of the source node.

\item[\code{dest}] an integer or character identifier of the destination
node.

\end{description}
\end{Section}
\inputencoding{utf8}
\HeaderA{SimInf\_model}{Create a \code{SimInf\_model}}{SimInf.Rul.model}
%
\begin{Description}
Create a \code{SimInf\_model}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SimInf_model(
  G,
  S,
  tspan,
  events = NULL,
  ldata = NULL,
  gdata = NULL,
  U = NULL,
  u0 = NULL,
  v0 = NULL,
  V = NULL,
  E = NULL,
  N = NULL,
  C_code = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{G}] Dependency graph that indicates the transition rates that
need to be updated after a given state transition has occured.
A non-zero entry in element \code{G[i, i]} indicates that
transition rate \code{i} needs to be recalculated if the state
transition \code{j} occurs. Sparse matrix (\eqn{Nt \times Nt}{})
of object class
\code{\LinkA{dgCMatrix}{dgCMatrix}}.

\item[\code{S}] Each column corresponds to a transition, and execution of
state transition \code{j} amounts to adding the \code{S[, j]}
to the state vector of the node where the state transition
occurred.  Sparse matrix (\eqn{Nc \times Nt}{}) of object class
\code{\LinkA{dgCMatrix}{dgCMatrix}}.

\item[\code{tspan}] A vector (length >= 1) of increasing time points
where the state of each node is to be returned. Can be either
an \code{integer} or a \code{Date} vector. A \code{Date}
vector is coerced to a numeric vector as days, where
\code{tspan[1]} becomes the day of the year of the first year
of \code{tspan}. The dates are added as names to the numeric
vector.

\item[\code{events}] A \code{data.frame} with the scheduled events.

\item[\code{ldata}] local data for the nodes. Can either be specified as
a \code{data.frame} with one row per node. Or as a matrix
where each column \code{ldata[, j]} contains the local data
vector for the node \code{j}. The local data vector is passed
as an argument to the transition rate functions and the post
time step function.

\item[\code{gdata}] A numeric vector with global data that is common to
all nodes. The global data vector is passed as an argument to
the transition rate functions and the post time step function.

\item[\code{U}] The result matrix with the number of individuals in each
disease state in every node (\eqn{N_n N_c \times}{}
\code{length(tspan)}).  \code{U[, j]} contains the number of
individuals in each disease state at
\code{tspan[j]}. \code{U[1:Nc, j]} contains the state of node
\code{1} at \code{tspan[j]}. \code{U[(Nc + 1):(2 * Nc), j]}
contains the state of node \code{2} at \code{tspan[j]} etc.

\item[\code{u0}] The initial state vector. Either a matrix (\eqn{N_c
\times N_n}{}) or a a \code{data.frame} with the number of
individuals in each compartment in every node.

\item[\code{v0}] The initial continuous state vector in every node.
(\code{dim(ldata)[1]} \eqn{\times N_N}{}). The continuous state
vector is updated by the specific model during the simulation
in the post time step function.

\item[\code{V}] The result matrix for the real-valued continous
compartment state (\eqn{N_n}{}\code{dim(ldata)[1]} \eqn{\times}{}
\code{length(tspan)}).  \code{V[, j]} contains the real-valued
state of the system at \code{tspan[j]}.

\item[\code{E}] Sparse matrix to handle scheduled events, see
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}.

\item[\code{N}] Sparse matrix to handle scheduled events, see
\code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}.

\item[\code{C\_code}] Character vector with optional model C code. If
non-empty, the C code is written to a temporary C-file when
the \code{run} method is called.  The temporary C-file is
compiled and the resulting DLL is dynamically loaded. The DLL
is unloaded and the temporary files are removed after running
the model.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\LinkA{SimInf\_model}{SimInf.Rul.model.Rdash.class}
\end{Value}
\inputencoding{utf8}
\HeaderA{SimInf\_model-class}{Class \code{"SimInf\_model"}}{SimInf.Rul.model.Rdash.class}
%
\begin{Description}
Class to handle data for the \code{SimInf\_model}.
\end{Description}
%
\begin{Section}{Slots}

\begin{description}

\item[\code{G}] Dependency graph that indicates the transition rates that
need to be updated after a given state transition has occured.
A non-zero entry in element \code{G[i, i]} indicates that
transition rate \code{i} needs to be recalculated if the state
transition \code{j} occurs. Sparse matrix (\eqn{Nt \times Nt}{})
of object class
\code{\LinkA{dgCMatrix}{dgCMatrix}}.

\item[\code{S}] Each column corresponds to a state transition, and
execution of state transition \code{j} amounts to adding the
\code{S[, j]} column to the state vector \code{u[, i]} of node
\emph{i} where the transition occurred. Sparse matrix (\eqn{Nc
\times Nt}{}) of object class
\code{\LinkA{dgCMatrix}{dgCMatrix}}.

\item[\code{U}] The result matrix with the number of individuals in each
compartment in every node. \code{U[, j]} contains the number
of individuals in each compartment at
\code{tspan[j]}. \code{U[1:Nc, j]} contains the number of
individuals in node 1 at \code{tspan[j]}. \code{U[(Nc + 1):(2
* Nc), j]} contains the number of individuals in node 2 at
\code{tspan[j]} etc. Integer matrix (\eqn{N_n N_c \times}{}
\code{length(tspan)}).

\item[\code{U\_sparse}] If the model was configured to write the solution
to a sparse matrix
(\code{\LinkA{dgCMatrix}{dgCMatrix}}) the
\code{U\_sparse} contains the data and \code{U} is empty. The
layout of the data in \code{U\_sparse} is identical to
\code{U}. Please note that \code{U\_sparse} is numeric and
\code{U} is integer.

\item[\code{V}] The result matrix for the real-valued continuous
state. \code{V[, j]} contains the real-valued state of the
system at \code{tspan[j]}. Numeric matrix
(\eqn{N_n}{}\code{dim(ldata)[1]} \eqn{\times}{}
\code{length(tspan)}).

\item[\code{V\_sparse}] If the model was configured to write the solution
to a sparse matrix
(\code{\LinkA{dgCMatrix}{dgCMatrix}}) the
\code{V\_sparse} contains the data and \code{V} is empty. The
layout of the data in \code{V\_sparse} is identical to
\code{V}.

\item[\code{ldata}] A matrix with local data for the nodes. The column
\code{ldata[, j]} contains the local data vector for the node
\code{j}. The local data vector is passed as an argument to
the transition rate functions and the post time step function.

\item[\code{gdata}] A numeric vector with global data that is common to
all nodes.  The global data vector is passed as an argument to
the transition rate functions and the post time step function.

\item[\code{tspan}] A vector of increasing time points where the state of
each node is to be returned.

\item[\code{u0}] The initial state vector (\eqn{N_c \times N_n}{}) with the
number of individuals in each compartment in every node.

\item[\code{v0}] The initial value for the real-valued continuous state.
Numeric matrix (\code{dim(ldata)[1]} \eqn{\times N_n}{}).

\item[\code{events}] Scheduled events \code{\LinkA{SimInf\_events}{SimInf.Rul.events.Rdash.class}}

\item[\code{replicates}] Number of replicates of the model.

\item[\code{C\_code}] Character vector with optional model C code. If
non-empty, the C code is written to a temporary C-file when
the \code{run} method is called.  The temporary C-file is
compiled and the resulting DLL is dynamically loaded. The DLL
is unloaded and the temporary files are removed after running
the model.

\end{description}
\end{Section}
\inputencoding{utf8}
\HeaderA{SimInf\_pfilter-class}{Class \code{"SimInf\_pfilter"}}{SimInf.Rul.pfilter.Rdash.class}
%
\begin{Description}
Class \code{"SimInf\_pfilter"}
\end{Description}
%
\begin{Section}{Slots}

\begin{description}

\item[\code{model}] A \code{SimInf\_model} object with one filtered
trajectory attached.

\item[\code{n\_particles}] An integer with the number of particles that was
used at each timestep.

\item[\code{loglik}] The estimated log likelihood.

\item[\code{ess}] A numeric vector with the effective sample size (ESS).
The effective sample size is computed as
\deqn{\left(\sum_{i=1}^N\!(w_{t}^{i})^2\right)^{-1},}{} where \eqn{w_{t}^{i}}{} is the normalized
weight of particle \eqn{i}{} at time \eqn{t}{}.

\end{description}
\end{Section}
\inputencoding{utf8}
\HeaderA{SimInf\_pmcmc-class}{Class \code{"SimInf\_pmcmc"}}{SimInf.Rul.pmcmc.Rdash.class}
%
\begin{Description}
Class \code{"SimInf\_pmcmc"}
\end{Description}
%
\begin{Section}{Slots}

\begin{description}

\item[\code{model}] The \code{SimInf\_model} object to estimate parameters
in.

\item[\code{priors}] A \code{data.frame} containing the four columns
\code{parameter}, \code{distribution}, \code{p1} and
\code{p2}. The column \code{parameter} gives the name of the
parameter referred to in the model. The column
\code{distribution} contains the name of the prior
distribution. Valid distributions are 'gamma', 'normal' or
'uniform'. The column \code{p1} is a numeric vector with the
first hyperparameter for each prior: 'gamma') shape,
'lognormal') logmean, 'normal') mean, and 'uniform') lower
bound. The column \code{p2} is a numeric vector with the
second hyperparameter for each prior: 'gamma') rate,
'lognormal') standard deviation on the log scale, 'normal')
standard deviation, and 'uniform') upper bound.

\item[\code{target}] Character vector (\code{gdata} or \code{ldata}) that
determines if the \code{pmcmc} method estimates parameters in
\code{model@gdata} or in \code{model@ldata}.

\item[\code{pars}] Index to the parameters in \code{target}.

\item[\code{n\_particles}] An integer with the number of particles (> 1) to
use in the bootstrap particle filter.

\item[\code{data}] A \code{data.frame} holding the time series data for
the observation process.

\item[\code{chain}] A matrix where each row contains \code{logPost},
\code{logLik}, \code{logPrior}, \code{accept}, and the
\code{parameters} for each iteration.

\item[\code{covmat}] A named numeric \code{(npars x npars)} matrix with
covariances to use as initial proposal matrix.

\item[\code{adaptmix}] Mixing proportion for adaptive proposal.

\item[\code{adaptive}] Controls when to start adaptive update.

\end{description}
\end{Section}
%
\begin{SeeAlso}
\code{\LinkA{pmcmc}{pmcmc}} and \code{\LinkA{continue\_pmcmc}{continue.Rul.pmcmc}}.
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{SIR}{Create an \acronym{SIR} model}{SIR}
%
\begin{Description}
Create an \acronym{SIR} model to be used by the simulation
framework.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SIR(u0, tspan, events = NULL, beta = NULL, gamma = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{u0}] A \code{data.frame} with the initial state in each node,
i.e., the number of individuals in each compartment in each
node when the simulation starts (see `Details'). The
parameter \code{u0} can also be an object that can be coerced
to a \code{data.frame}, e.g., a named numeric vector will be
coerced to a one row \code{data.frame}.

\item[\code{tspan}] A vector (length >= 1) of increasing time points
where the state of each node is to be returned. Can be either
an \code{integer} or a \code{Date} vector. A \code{Date}
vector is coerced to a numeric vector as days, where
\code{tspan[1]} becomes the day of the year of the first year
of \code{tspan}. The dates are added as names to the numeric
vector.

\item[\code{events}] a \code{data.frame} with the scheduled events, see
\code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.

\item[\code{beta}] A numeric vector with the transmission rate from
susceptible to infected where each node can have a different
beta value. The vector must have length 1 or \code{nrow(u0)}.
If the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.

\item[\code{gamma}] A numeric vector with the recovery rate from infected
to recovered where each node can have a different gamma
value. The vector must have length 1 or \code{nrow(u0)}. If
the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The \acronym{SIR} model contains three compartments; number of
susceptible (S), number of infectious (I), and number of
recovered (R).  Moreover, it has two state transitions,
\deqn{S \stackrel{\beta S I / N}{\longrightarrow} I}{}
\deqn{I \stackrel{\gamma I}{\longrightarrow} R}{}
where \eqn{\beta}{} is the transmission rate, \eqn{\gamma}{} is the
recovery rate, and \eqn{N=S+I+R}{}.

The argument \code{u0} must be a \code{data.frame} with one row for
each node with the following columns:
\begin{description}

\item[S] The number of sucsceptible in each node
\item[I] The number of infected in each node
\item[R] The number of recovered in each node

\end{description}

\end{Details}
%
\begin{Value}
A \code{\LinkA{SimInf\_model}{SimInf.Rul.model}} of class \code{SIR}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model object.
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIR model and plot the result.
set.seed(22)
result <- run(model)
plot(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SIR-class}{Definition of the \acronym{SIR} model}{SIR.Rdash.class}
%
\begin{Description}
Class to handle the \acronym{SIR} \code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.
\end{Description}
%
\begin{Details}
The \acronym{SIR} model contains three compartments; number of
susceptible (S), number of infectious (I), and number of
recovered (R).  Moreover, it has two state transitions,
\deqn{S \stackrel{\beta S I / N}{\longrightarrow} I}{}
\deqn{I \stackrel{\gamma I}{\longrightarrow} R}{}
where \eqn{\beta}{} is the transmission rate, \eqn{\gamma}{} is the
recovery rate, and \eqn{N=S+I+R}{}.
\end{Details}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model object.
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIR model and plot the result.
set.seed(22)
result <- run(model)
plot(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SIS}{Create an \acronym{SIS} model}{SIS}
%
\begin{Description}
Create an \acronym{SIS} model to be used by the simulation
framework.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SIS(u0, tspan, events = NULL, beta = NULL, gamma = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{u0}] A \code{data.frame} with the initial state in each node,
i.e., the number of individuals in each compartment in each
node when the simulation starts (see `Details'). The
parameter \code{u0} can also be an object that can be coerced
to a \code{data.frame}, e.g., a named numeric vector will be
coerced to a one row \code{data.frame}.

\item[\code{tspan}] A vector (length >= 1) of increasing time points
where the state of each node is to be returned. Can be either
an \code{integer} or a \code{Date} vector. A \code{Date}
vector is coerced to a numeric vector as days, where
\code{tspan[1]} becomes the day of the year of the first year
of \code{tspan}. The dates are added as names to the numeric
vector.

\item[\code{events}] a \code{data.frame} with the scheduled events, see
\code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.

\item[\code{beta}] A numeric vector with the transmission rate from
susceptible to infected where each node can have a different
beta value. The vector must have length 1 or \code{nrow(u0)}.
If the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.

\item[\code{gamma}] A numeric vector with the recovery rate from infected
to recovered where each node can have a different gamma
value. The vector must have length 1 or \code{nrow(u0)}. If
the vector has length 1, but the model contains more nodes,
the beta value is repeated in all nodes.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The \acronym{SIS} model contains two compartments; number of
susceptible (S), and number of infectious (I).  Moreover, it has
two state transitions, \deqn{S \stackrel{\beta S I /
N}{\longrightarrow} I}{} \deqn{I
\stackrel{\gamma I}{\longrightarrow} S}{} where
\eqn{\beta}{} is the transmission rate, \eqn{\gamma}{} is the recovery
rate, and \eqn{N=S+I}{}.

The argument \code{u0} must be a \code{data.frame} with one row for
each node with the following columns:
\begin{description}

\item[S] The number of sucsceptible in each node
\item[I] The number of infected in each node

\end{description}

\end{Details}
%
\begin{Value}
A \code{\LinkA{SimInf\_model}{SimInf.Rul.model}} of class \code{SIS}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIS model object.
model <- SIS(u0 = data.frame(S = 99, I = 1),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIS model and plot the result.
set.seed(22)
result <- run(model)
plot(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SIS-class}{Definition of the \acronym{SIS} model}{SIS.Rdash.class}
%
\begin{Description}
Class to handle the \acronym{SIS} \code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.
\end{Description}
%
\begin{Details}
The \acronym{SIS} model contains two compartments; number of
susceptible (S), and number of infectious (I).  Moreover, it has
two state transitions, \deqn{S \stackrel{\beta S I /
N}{\longrightarrow} I}{} \deqn{I
\stackrel{\gamma I}{\longrightarrow} S}{} where
\eqn{\beta}{} is the transmission rate, \eqn{\gamma}{} is the recovery
rate, and \eqn{N=S+I}{}.
\end{Details}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIS model object.
model <- SIS(u0 = data.frame(S = 99, I = 1),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIS model and plot the result.
set.seed(22)
result <- run(model)
plot(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SISe}{Create a SISe model}{SISe}
%
\begin{Description}
Create an `SISe' model to be used by the simulation
framework.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SISe(
  u0,
  tspan,
  events = NULL,
  phi = NULL,
  upsilon = NULL,
  gamma = NULL,
  alpha = NULL,
  beta_t1 = NULL,
  beta_t2 = NULL,
  beta_t3 = NULL,
  beta_t4 = NULL,
  end_t1 = NULL,
  end_t2 = NULL,
  end_t3 = NULL,
  end_t4 = NULL,
  epsilon = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{u0}] A \code{data.frame} with the initial state in each node,
i.e., the number of individuals in each compartment in each
node when the simulation starts (see `Details'). The
parameter \code{u0} can also be an object that can be coerced
to a \code{data.frame}, e.g., a named numeric vector will be
coerced to a one row \code{data.frame}.

\item[\code{tspan}] A vector (length >= 1) of increasing time points
where the state of each node is to be returned. Can be either
an \code{integer} or a \code{Date} vector. A \code{Date}
vector is coerced to a numeric vector as days, where
\code{tspan[1]} becomes the day of the year of the first year
of \code{tspan}. The dates are added as names to the numeric
vector.

\item[\code{events}] a \code{data.frame} with the scheduled events, see
\code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.

\item[\code{phi}] A numeric vector with the initial environmental
infectious pressure in each node. Will be repeated to the
length of nrow(u0). Default is NULL which gives 0 in each
node.

\item[\code{upsilon}] Indirect transmission rate of the environmental
infectious pressure

\item[\code{gamma}] The recovery rate from infected to susceptible

\item[\code{alpha}] Shed rate from infected individuals

\item[\code{beta\_t1}] The decay of the environmental infectious pressure
in interval 1.

\item[\code{beta\_t2}] The decay of the environmental infectious pressure
in interval 2.

\item[\code{beta\_t3}] The decay of the environmental infectious pressure
in interval 3.

\item[\code{beta\_t4}] The decay of the environmental infectious pressure
in interval 4.

\item[\code{end\_t1}] vector with the non-inclusive day of the year that
ends interval 1 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t2}] vector with the non-inclusive day of the year that
ends interval 2 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t3}] vector with the non-inclusive day of the year that
ends interval 3 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t4}] vector with the non-inclusive day of the year that
ends interval 4 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{epsilon}] The background environmental infectious pressure
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The `SISe' model contains two compartments; number of
susceptible (S) and number of infectious (I). Additionally, it
contains an environmental compartment to model shedding of a
pathogen to the environment. Consequently, the model has two state
transitions,

\deqn{S \stackrel{\upsilon \varphi S}{\longrightarrow} I}{}

\deqn{I \stackrel{\gamma I}{\longrightarrow} S}{}

where the transition rate per unit of time from susceptible to
infected is proportional to the concentration of the environmental
contamination \eqn{\varphi}{} in each node. Moreover, the
transition rate from infected to susceptible is the recovery rate
\eqn{\gamma}{}, measured per individual and per unit of
time. Finally, the environmental infectious pressure in each node
is evolved by,

\deqn{\frac{d\varphi(t)}{dt} = \frac{\alpha I(t)}{N(t)} - \beta(t)
\varphi(t) + \epsilon}{}

where \eqn{\alpha}{} is the average shedding rate of the pathogen to
the environment per infected individual and \eqn{N = S + I}{} the
size of the node. The seasonal decay and removal of the pathogen
is captured by \eqn{\beta(t)}{}. It is also possible to include a
small background infectious pressure \eqn{\epsilon}{} to allow for
other indirect sources of environmental contamination. The
environmental infectious pressure \eqn{\varphi(t)}{} in each
node is evolved each time unit by the Euler forward method. The
value of \eqn{\varphi(t)}{} is saved at the time-points
specified in \code{tspan}.

The argument \code{u0} must be a \code{data.frame} with one row for
each node with the following columns:
\begin{description}

\item[S] The number of sucsceptible in each node
\item[I] The number of infected in each node

\end{description}

\end{Details}
%
\begin{Value}
\code{SISe}
\end{Value}
%
\begin{Section}{Beta}

The time dependent beta is divided into four intervals of the year
\begin{alltt}
where 0 <= day < 365

Case 1: END_1 < END_2 < END_3 < END_4
INTERVAL_1 INTERVAL_2     INTERVAL_3     INTERVAL_4     INTERVAL_1
[0, END_1) [END_1, END_2) [END_2, END_3) [END_3, END_4) [END_4, 365)

Case 2: END_3 < END_4 < END_1 < END_2
INTERVAL_3 INTERVAL_4     INTERVAL_1     INTERVAL_2     INTERVAL_3
[0, END_3) [END_3, END_4) [END_4, END_1) [END_1, END_2) [END_2, 365)

Case 3: END_4 < END_1 < END_2 < END_3
INTERVAL_4 INTERVAL_1     INTERVAL_2     INTERVAL_3     INTERVAL_4
[0, END_4) [END_4, END_1) [END_1, END_2) [END_2, END_3) [END_3, 365)
\end{alltt}

\end{Section}
\inputencoding{utf8}
\HeaderA{SISe-class}{Definition of the \code{SISe} model}{SISe.Rdash.class}
%
\begin{Description}
Class to handle the SISe \code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.
\end{Description}
\inputencoding{utf8}
\HeaderA{SISe3}{Create a \code{SISe3} model}{SISe3}
%
\begin{Description}
Create a \code{SISe3} model to be used by the simulation
framework.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SISe3(
  u0,
  tspan,
  events = NULL,
  phi = NULL,
  upsilon_1 = NULL,
  upsilon_2 = NULL,
  upsilon_3 = NULL,
  gamma_1 = NULL,
  gamma_2 = NULL,
  gamma_3 = NULL,
  alpha = NULL,
  beta_t1 = NULL,
  beta_t2 = NULL,
  beta_t3 = NULL,
  beta_t4 = NULL,
  end_t1 = NULL,
  end_t2 = NULL,
  end_t3 = NULL,
  end_t4 = NULL,
  epsilon = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{u0}] A \code{data.frame} with the initial state in each node,
i.e., the number of individuals in each compartment in each
node when the simulation starts (see `Details'). The
parameter \code{u0} can also be an object that can be coerced
to a \code{data.frame}, e.g., a named numeric vector will be
coerced to a one row \code{data.frame}.

\item[\code{tspan}] A vector (length >= 1) of increasing time points
where the state of each node is to be returned. Can be either
an \code{integer} or a \code{Date} vector. A \code{Date}
vector is coerced to a numeric vector as days, where
\code{tspan[1]} becomes the day of the year of the first year
of \code{tspan}. The dates are added as names to the numeric
vector.

\item[\code{events}] a \code{data.frame} with the scheduled events, see
\code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.

\item[\code{phi}] A numeric vector with the initial environmental
infectious pressure in each node. Will be repeated to the
length of nrow(u0). Default is NULL which gives 0 in each
node.

\item[\code{upsilon\_1}] Indirect transmission rate of the environmental
infectious pressure in age category 1

\item[\code{upsilon\_2}] Indirect transmission rate of the environmental
infectious pressure in age category 2

\item[\code{upsilon\_3}] Indirect transmission rate of the environmental
infectious pressure in age category 3

\item[\code{gamma\_1}] The recovery rate from infected to susceptible for
age category 1

\item[\code{gamma\_2}] The recovery rate from infected to susceptible for
age category 2

\item[\code{gamma\_3}] The recovery rate from infected to susceptible for
age category 3

\item[\code{alpha}] Shed rate from infected individuals

\item[\code{beta\_t1}] The decay of the environmental infectious pressure
in interval 1.

\item[\code{beta\_t2}] The decay of the environmental infectious pressure
in interval 2.

\item[\code{beta\_t3}] The decay of the environmental infectious pressure
in interval 3.

\item[\code{beta\_t4}] The decay of the environmental infectious pressure
in interval 4.

\item[\code{end\_t1}] vector with the non-inclusive day of the year that
ends interval 1 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t2}] vector with the non-inclusive day of the year that
ends interval 2 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t3}] vector with the non-inclusive day of the year that
ends interval 3 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t4}] vector with the non-inclusive day of the year that
ends interval 4 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{epsilon}] The background environmental infectious pressure
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The \code{SISe3} model contains two compartments in three age
categories; number of susceptible (S\_1, S\_2, S\_3) and number of
infectious (I\_1, I\_2, I\_3). Additionally, it contains an
environmental compartment to model shedding of a pathogen to the
environment. Consequently, the model has six state transitions,

\deqn{S_1 \stackrel{\upsilon_1 \varphi S_1}{\longrightarrow} I_1}{}

\deqn{I_1 \stackrel{\gamma_1 I_1}{\longrightarrow} S_1}{}

\deqn{S_2 \stackrel{\upsilon_2 \varphi S_2}{\longrightarrow} I_2}{}

\deqn{I_2 \stackrel{\gamma_2 I_2}{\longrightarrow} S_2}{}

\deqn{S_3 \stackrel{\upsilon_3 \varphi S_3}{\longrightarrow} I_3}{}

\deqn{I_3 \stackrel{\gamma_3 I_3}{\longrightarrow} S_3}{}

where the transition rate per unit of time from susceptible to
infected is proportional to the concentration of the environmental
contamination \eqn{\varphi}{} in each node. Moreover, the
transition rate from infected to susceptible is the recovery rate
\eqn{\gamma_1, \gamma_2, \gamma_3}{}, measured per individual and
per unit of time. Finally, the environmental infectious pressure
in each node is evolved by,

\deqn{\frac{d\varphi(t)}{dt} = \frac{\alpha \left(I_1(t) + I_2(t)
+ I_3(t)\right)}{N(t)} - \beta(t) \varphi(t) + \epsilon}{}

where \eqn{\alpha}{} is the average shedding rate of the pathogen to
the environment per infected individual and \eqn{N = S_1 + S_2 +
S_3 + I_1 + I_2 + I_3}{} the size of the node. The seasonal decay
and removal of the pathogen is captured by \eqn{\beta(t)}{}. It is
also possible to include a small background infectious pressure
\eqn{\epsilon}{} to allow for other indirect sources of
environmental contamination. The environmental infectious pressure
\eqn{\varphi(t)}{} in each node is evolved each time unit by
the Euler forward method. The value of \eqn{\varphi(t)}{} is
saved at the time-points specified in \code{tspan}.

The argument \code{u0} must be a \code{data.frame} with one row for
each node with the following columns:
\begin{description}

\item[S\_1] The number of sucsceptible in age category 1
\item[I\_1] The number of infected in age category 1
\item[S\_2] The number of sucsceptible in age category 2
\item[I\_2] The number of infected in age category 2
\item[S\_3] The number of sucsceptible in age category 3
\item[I\_3] The number of infected in age category 3

\end{description}

\end{Details}
%
\begin{Value}
\code{SISe3}
\end{Value}
%
\begin{Section}{Beta}

The time dependent beta is divided into four intervals of the year
\begin{alltt}
where 0 <= day < 365

Case 1: END_1 < END_2 < END_3 < END_4
INTERVAL_1 INTERVAL_2     INTERVAL_3     INTERVAL_4     INTERVAL_1
[0, END_1) [END_1, END_2) [END_2, END_3) [END_3, END_4) [END_4, 365)

Case 2: END_3 < END_4 < END_1 < END_2
INTERVAL_3 INTERVAL_4     INTERVAL_1     INTERVAL_2     INTERVAL_3
[0, END_3) [END_3, END_4) [END_4, END_1) [END_1, END_2) [END_2, 365)

Case 3: END_4 < END_1 < END_2 < END_3
INTERVAL_4 INTERVAL_1     INTERVAL_2     INTERVAL_3     INTERVAL_4
[0, END_4) [END_4, END_1) [END_1, END_2) [END_2, END_3) [END_3, 365)
\end{alltt}

\end{Section}
\inputencoding{utf8}
\HeaderA{SISe3-class}{Definition of the `SISe3' model}{SISe3.Rdash.class}
%
\begin{Description}
Class to handle the SISe3 \code{\LinkA{SimInf\_model}{SimInf.Rul.model}} model.
\end{Description}
\inputencoding{utf8}
\HeaderA{SISe3\_sp}{Create an \code{SISe3\_sp} model}{SISe3.Rul.sp}
%
\begin{Description}
Create an \code{SISe3\_sp} model to be used by the simulation
framework.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SISe3_sp(
  u0,
  tspan,
  events = NULL,
  phi = NULL,
  upsilon_1 = NULL,
  upsilon_2 = NULL,
  upsilon_3 = NULL,
  gamma_1 = NULL,
  gamma_2 = NULL,
  gamma_3 = NULL,
  alpha = NULL,
  beta_t1 = NULL,
  beta_t2 = NULL,
  beta_t3 = NULL,
  beta_t4 = NULL,
  end_t1 = NULL,
  end_t2 = NULL,
  end_t3 = NULL,
  end_t4 = NULL,
  distance = NULL,
  coupling = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{u0}] A \code{data.frame} with the initial state in each node,
i.e., the number of individuals in each compartment in each
node when the simulation starts (see `Details'). The
parameter \code{u0} can also be an object that can be coerced
to a \code{data.frame}, e.g., a named numeric vector will be
coerced to a one row \code{data.frame}.

\item[\code{tspan}] A vector (length >= 1) of increasing time points
where the state of each node is to be returned. Can be either
an \code{integer} or a \code{Date} vector. A \code{Date}
vector is coerced to a numeric vector as days, where
\code{tspan[1]} becomes the day of the year of the first year
of \code{tspan}. The dates are added as names to the numeric
vector.

\item[\code{events}] a \code{data.frame} with the scheduled events, see
\code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.

\item[\code{phi}] A numeric vector with the initial environmental
infectious pressure in each node. Will be repeated to the
length of nrow(u0). Default is NULL which gives 0 in each
node.

\item[\code{upsilon\_1}] Indirect transmission rate of the environmental
infectious pressure in age category 1

\item[\code{upsilon\_2}] Indirect transmission rate of the environmental
infectious pressure in age category 2

\item[\code{upsilon\_3}] Indirect transmission rate of the environmental
infectious pressure in age category 3

\item[\code{gamma\_1}] The recovery rate from infected to susceptible for
age category 1

\item[\code{gamma\_2}] The recovery rate from infected to susceptible for
age category 2

\item[\code{gamma\_3}] The recovery rate from infected to susceptible for
age category 3

\item[\code{alpha}] Shed rate from infected individuals

\item[\code{beta\_t1}] The decay of the environmental infectious pressure
in interval 1.

\item[\code{beta\_t2}] The decay of the environmental infectious pressure
in interval 2.

\item[\code{beta\_t3}] The decay of the environmental infectious pressure
in interval 3.

\item[\code{beta\_t4}] The decay of the environmental infectious pressure
in interval 4.

\item[\code{end\_t1}] vector with the non-inclusive day of the year that
ends interval 1 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t2}] vector with the non-inclusive day of the year that
ends interval 2 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t3}] vector with the non-inclusive day of the year that
ends interval 3 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t4}] vector with the non-inclusive day of the year that
ends interval 4 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{distance}] The distance matrix between neighboring nodes

\item[\code{coupling}] The coupling between neighboring nodes
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The \code{SISe3\_sp} model contains two compartments in three age
categories; number of susceptible (S\_1, S\_2, S\_3) and number of
infectious (I\_1, I\_2, I\_3). Additionally, it contains an
environmental compartment to model shedding of a pathogen to the
environment. Moreover, it also includes a spatial coupling of the
environmental contamination among proximal nodes to capture
between-node spread unrelated to moving infected
individuals. Consequently, the model has six state transitions,

\deqn{S_1 \stackrel{\upsilon_1 \varphi S_1}{\longrightarrow} I_1}{}

\deqn{I_1 \stackrel{\gamma_1 I_1}{\longrightarrow} S_1}{}

\deqn{S_2 \stackrel{\upsilon_2 \varphi S_2}{\longrightarrow} I_2}{}

\deqn{I_2 \stackrel{\gamma_2 I_2}{\longrightarrow} S_2}{}

\deqn{S_3 \stackrel{\upsilon_3 \varphi S_3}{\longrightarrow} I_3}{}

\deqn{I_3 \stackrel{\gamma_3 I_3}{\longrightarrow} S_3}{}

where the transition rate per unit of time from susceptible to
infected is proportional to the concentration of the environmental
contamination \eqn{\varphi}{} in each node. Moreover, the
transition rate from infected to susceptible is the recovery rate
\eqn{\gamma_1, \gamma_2, \gamma_3}{}, measured per individual and
per unit of time. Finally, the environmental infectious pressure
in each node is evolved by,

\deqn{\frac{d \varphi_i(t)}{dt} = \frac{\alpha \left(I_{i,1}(t) +
I_{i,2}(t) + I_{i,3}(t)\right)}{N_i(t)} +
\sum_k{\frac{\varphi_k(t) N_k(t) - \varphi_i(t) N_i(t)}{N_i(t)}
\cdot \frac{D}{d_{ik}}} - \beta(t) \varphi_i(t)}{}

where \eqn{\alpha}{} is the average shedding rate of the pathogen to
the environment per infected individual and \eqn{N = S_1 + S_2 +
S_3 + I_1 + I_2 + I_3}{} the size of the node. Next comes the
spatial coupling among proximal nodes, where \eqn{D}{} is the rate
of the local spread and \eqn{d_{ik}}{} the distance between holdings
\eqn{i}{} and \eqn{k}{}. The seasonal decay and removal of the
pathogen is captured by \eqn{\beta(t)}{}. The environmental
infectious pressure \eqn{\varphi(t)}{} in each node is
evolved each time unit by the Euler forward method. The value of
\eqn{\varphi(t)}{} is saved at the time-points specified in
\code{tspan}.

The argument \code{u0} must be a \code{data.frame} with one row for
each node with the following columns:
\begin{description}

\item[S\_1] The number of sucsceptible in age category 1
\item[I\_1] The number of infected in age category 1
\item[S\_2] The number of sucsceptible in age category 2
\item[I\_2] The number of infected in age category 2
\item[S\_3] The number of sucsceptible in age category 3
\item[I\_3] The number of infected in age category 3

\end{description}

\end{Details}
%
\begin{Value}
\code{SISe3\_sp}
\end{Value}
%
\begin{Section}{Beta}

The time dependent beta is divided into four intervals of the year
\begin{alltt}
where 0 <= day < 365

Case 1: END_1 < END_2 < END_3 < END_4
INTERVAL_1 INTERVAL_2     INTERVAL_3     INTERVAL_4     INTERVAL_1
[0, END_1) [END_1, END_2) [END_2, END_3) [END_3, END_4) [END_4, 365)

Case 2: END_3 < END_4 < END_1 < END_2
INTERVAL_3 INTERVAL_4     INTERVAL_1     INTERVAL_2     INTERVAL_3
[0, END_3) [END_3, END_4) [END_4, END_1) [END_1, END_2) [END_2, 365)

Case 3: END_4 < END_1 < END_2 < END_3
INTERVAL_4 INTERVAL_1     INTERVAL_2     INTERVAL_3     INTERVAL_4
[0, END_4) [END_4, END_1) [END_1, END_2) [END_2, END_3) [END_3, 365)
\end{alltt}

\end{Section}
\inputencoding{utf8}
\HeaderA{SISe3\_sp-class}{Definition of the `SISe3\_sp' model}{SISe3.Rul.sp.Rdash.class}
%
\begin{Description}
Class to handle the SISe3\_sp \code{\LinkA{SimInf\_model}{SimInf.Rul.model}} model.
\end{Description}
\inputencoding{utf8}
\HeaderA{SISe\_sp}{Create a \code{SISe\_sp} model}{SISe.Rul.sp}
%
\begin{Description}
Create a \code{SISe\_sp} model to be used by the simulation
framework.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SISe_sp(
  u0,
  tspan,
  events = NULL,
  phi = NULL,
  upsilon = NULL,
  gamma = NULL,
  alpha = NULL,
  beta_t1 = NULL,
  beta_t2 = NULL,
  beta_t3 = NULL,
  beta_t4 = NULL,
  end_t1 = NULL,
  end_t2 = NULL,
  end_t3 = NULL,
  end_t4 = NULL,
  coupling = NULL,
  distance = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{u0}] A \code{data.frame} with the initial state in each node,
i.e., the number of individuals in each compartment in each
node when the simulation starts (see `Details'). The
parameter \code{u0} can also be an object that can be coerced
to a \code{data.frame}, e.g., a named numeric vector will be
coerced to a one row \code{data.frame}.

\item[\code{tspan}] A vector (length >= 1) of increasing time points
where the state of each node is to be returned. Can be either
an \code{integer} or a \code{Date} vector. A \code{Date}
vector is coerced to a numeric vector as days, where
\code{tspan[1]} becomes the day of the year of the first year
of \code{tspan}. The dates are added as names to the numeric
vector.

\item[\code{events}] a \code{data.frame} with the scheduled events, see
\code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.

\item[\code{phi}] A numeric vector with the initial environmental
infectious pressure in each node. Will be repeated to the
length of nrow(u0). Default is NULL which gives 0 in each
node.

\item[\code{upsilon}] Indirect transmission rate of the environmental
infectious pressure

\item[\code{gamma}] The recovery rate from infected to susceptible

\item[\code{alpha}] Shed rate from infected individuals

\item[\code{beta\_t1}] The decay of the environmental infectious pressure
in interval 1.

\item[\code{beta\_t2}] The decay of the environmental infectious pressure
in interval 2.

\item[\code{beta\_t3}] The decay of the environmental infectious pressure
in interval 3.

\item[\code{beta\_t4}] The decay of the environmental infectious pressure
in interval 4.

\item[\code{end\_t1}] vector with the non-inclusive day of the year that
ends interval 1 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t2}] vector with the non-inclusive day of the year that
ends interval 2 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t3}] vector with the non-inclusive day of the year that
ends interval 3 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{end\_t4}] vector with the non-inclusive day of the year that
ends interval 4 in each node. Will be repeated to the length
of nrow(u0).

\item[\code{coupling}] The coupling between neighboring nodes

\item[\code{distance}] The distance matrix between neighboring nodes
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The \code{SISe\_sp} model contains two compartments; number of
susceptible (S) and number of infectious (I). Additionally, it
contains an environmental compartment to model shedding of a
pathogen to the environment. Moreover, it also includes a spatial
coupling of the environmental contamination among proximal nodes
to capture between-node spread unrelated to moving infected
individuals. Consequently, the model has two state transitions,

\deqn{S \stackrel{\upsilon \varphi S}{\longrightarrow} I}{}

\deqn{I \stackrel{\gamma I}{\longrightarrow} S}{}

where the transition rate per unit of time from susceptible to
infected is proportional to the concentration of the environmental
contamination \eqn{\varphi}{} in each node. Moreover, the
transition rate from infected to susceptible is the recovery rate
\eqn{\gamma}{}, measured per individual and per unit of
time. Finally, the environmental infectious pressure in each node
is evolved by,

\deqn{\frac{d \varphi_i(t)}{dt} = \frac{\alpha I_{i}(t)}{N_i(t)} +
\sum_k{\frac{\varphi_k(t) N_k(t) - \varphi_i(t) N_i(t)}{N_i(t)}
\cdot \frac{D}{d_{ik}}} - \beta(t) \varphi_i(t)}{}

where \eqn{\alpha}{} is the average shedding rate of the pathogen to
the environment per infected individual and \eqn{N = S + I}{} the
size of the node. Next comes the spatial coupling among proximal
nodes, where \eqn{D}{} is the rate of the local spread and
\eqn{d_{ik}}{} the distance between holdings \eqn{i}{} and
\eqn{k}{}. The seasonal decay and removal of the pathogen is
captured by \eqn{\beta(t)}{}. The environmental infectious pressure
\eqn{\varphi(t)}{} in each node is evolved each time unit by
the Euler forward method. The value of \eqn{\varphi(t)}{} is
saved at the time-points specified in \code{tspan}.

The argument \code{u0} must be a \code{data.frame} with one row for
each node with the following columns:
\begin{description}

\item[S] The number of sucsceptible
\item[I] The number of infected

\end{description}

\end{Details}
%
\begin{Value}
\code{SISe\_sp}
\end{Value}
%
\begin{Section}{Beta}

The time dependent beta is divided into four intervals of the year
\begin{alltt}
where 0 <= day < 365

Case 1: END_1 < END_2 < END_3 < END_4
INTERVAL_1 INTERVAL_2     INTERVAL_3     INTERVAL_4     INTERVAL_1
[0, END_1) [END_1, END_2) [END_2, END_3) [END_3, END_4) [END_4, 365)

Case 2: END_3 < END_4 < END_1 < END_2
INTERVAL_3 INTERVAL_4     INTERVAL_1     INTERVAL_2     INTERVAL_3
[0, END_3) [END_3, END_4) [END_4, END_1) [END_1, END_2) [END_2, 365)

Case 3: END_4 < END_1 < END_2 < END_3
INTERVAL_4 INTERVAL_1     INTERVAL_2     INTERVAL_3     INTERVAL_4
[0, END_4) [END_4, END_1) [END_1, END_2) [END_2, END_3) [END_3, 365)
\end{alltt}

\end{Section}
\inputencoding{utf8}
\HeaderA{SISe\_sp-class}{Definition of the \code{SISe\_sp} model}{SISe.Rul.sp.Rdash.class}
%
\begin{Description}
Class to handle the \code{SISe\_sp} \code{\LinkA{SimInf\_model}{SimInf.Rul.model}}.
\end{Description}
\inputencoding{utf8}
\HeaderA{summary,SimInf\_abc-method}{Detailed summary of a \code{SimInf\_abc} object}{summary,SimInf.Rul.abc.Rdash.method}
%
\begin{Description}
Detailed summary of a \code{SimInf\_abc} object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_abc'
summary(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_abc} object

\item[\code{...}] Additional arguments affecting the summary produced.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
None (invisible 'NULL').
\end{Value}
\inputencoding{utf8}
\HeaderA{summary,SimInf\_events-method}{Detailed summary of a \code{SimInf\_events} object}{summary,SimInf.Rul.events.Rdash.method}
%
\begin{Description}
Shows the number of scheduled events and the number of scheduled
events per event type.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_events'
summary(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_events} object

\item[\code{...}] Additional arguments affecting the summary produced.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
None (invisible 'NULL').
\end{Value}
\inputencoding{utf8}
\HeaderA{summary,SimInf\_indiv\_events-method}{Detailed summary of a \code{SimInf\_indiv\_events} object}{summary,SimInf.Rul.indiv.Rul.events.Rdash.method}
%
\begin{Description}
Detailed summary of a \code{SimInf\_indiv\_events} object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_indiv_events'
summary(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_indiv\_events} object

\item[\code{...}] Additional arguments affecting the summary produced.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
None (invisible 'NULL').
\end{Value}
\inputencoding{utf8}
\HeaderA{summary,SimInf\_model-method}{Detailed summary of a \code{SimInf\_model} object}{summary,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Detailed summary of a \code{SimInf\_model} object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_model'
summary(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_model} object

\item[\code{...}] Additional arguments affecting the summary produced.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
None (invisible 'NULL').
\end{Value}
\inputencoding{utf8}
\HeaderA{summary,SimInf\_pfilter-method}{Detailed summary of a \code{SimInf\_pfilter} object}{summary,SimInf.Rul.pfilter.Rdash.method}
%
\begin{Description}
Detailed summary of a \code{SimInf\_pfilter} object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pfilter'
summary(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_pfilter} object.

\item[\code{...}] Unused additional arguments.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{invisible(NULL)}.
\end{Value}
\inputencoding{utf8}
\HeaderA{summary,SimInf\_pmcmc-method}{Detailed summary of a \code{SimInf\_pmcmc} object}{summary,SimInf.Rul.pmcmc.Rdash.method}
%
\begin{Description}
Detailed summary of a \code{SimInf\_pmcmc} object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pmcmc'
summary(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The \code{SimInf\_pmcmc} object

\item[\code{...}] Not used.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
None (invisible 'NULL').
\end{Value}
\inputencoding{utf8}
\HeaderA{trajectory}{Generic function to extract data from a simulated trajectory}{trajectory}
%
\begin{Description}
Generic function to extract data from a simulated trajectory
\end{Description}
%
\begin{Usage}
\begin{verbatim}
trajectory(model, compartments = NULL, index = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] the object to extract the trajectory from.

\item[\code{compartments}] specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. \code{compartments = c('S', 'I', 'R')},
or as a formula e.g. \code{compartments = \textasciitilde{}S+I+R} (see
`Examples'). Default (\code{compartments=NULL}) is to
extract the number of individuals in each compartment i.e. the
data from all discrete state compartments in the model. In
models that also have continuous state variables e.g. the
\code{SISe} model, they are also included.

\item[\code{index}] indices specifying the subset of nodes to include
when extracting data. Default (\code{index = NULL}) is to
extract data from all nodes.

\item[\code{...}] Additional arguments, see
\code{\LinkA{trajectory,SimInf\_model-method}{trajectory,SimInf.Rul.model.Rdash.method}}
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{trajectory,SimInf\_model-method}{Extract data from a simulated trajectory}{trajectory,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Extract the number of individuals in each compartment in every
node after generating a single stochastic trajectory with
\code{\LinkA{run}{run}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_model'
trajectory(model, compartments, index, format = c("data.frame", "matrix"))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] the \code{SimInf\_model} object to extract the result
from.

\item[\code{compartments}] specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. \code{compartments = c('S', 'I', 'R')},
or as a formula e.g. \code{compartments = \textasciitilde{}S+I+R} (see
`Examples'). Default (\code{compartments=NULL}) is to
extract the number of individuals in each compartment i.e. the
data from all discrete state compartments in the model. In
models that also have continuous state variables e.g. the
\code{SISe} model, they are also included.

\item[\code{index}] indices specifying the subset of nodes to include
when extracting data. Default (\code{index = NULL}) is to
extract data from all nodes.

\item[\code{format}] the default (\code{format = "data.frame"}) is to
generate a \code{data.frame} with one row per node and
time-step with the number of individuals in each
compartment. Using \code{format = "matrix"} returns the result
as a matrix, which is the internal format (see
`Details').
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{data.frame} if \code{format = "data.frame"}, else
a matrix.
\end{Value}
%
\begin{Section}{Internal format of the discrete state variables}

Description of the layout of the internal matrix (\code{U})
that is returned if \code{format = "matrix"}. \code{U[, j]}
contains the number of individuals in each compartment at
\code{tspan[j]}. \code{U[1:Nc, j]} contains the number of
individuals in node 1 at \code{tspan[j]}. \code{U[(Nc + 1):(2
    * Nc), j]} contains the number of individuals in node 2 at
\code{tspan[j]} etc, where \code{Nc} is the number of
compartments in the model. The dimension of the matrix is
\eqn{N_n N_c \times}{} \code{length(tspan)} where \eqn{N_n}{} is
the number of nodes.
\end{Section}
%
\begin{Section}{Internal format of the continuous state variables}

Description of the layout of the matrix that is returned if
\code{format = "matrix"}. The result matrix for the
real-valued continuous state. \code{V[, j]} contains the
real-valued state of the system at \code{tspan[j]}. The
dimension of the matrix is \eqn{N_n}{}\code{dim(ldata)[1]}
\eqn{\times}{} \code{length(tspan)}.
\end{Section}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SIR' model with 6 nodes and initialize
## it to run over 10 days.
u0 <- data.frame(S = 100:105, I = 1:6, R = rep(0, 6))
model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)

## Run the model to generate a single stochastic trajectory.
result <- run(model)

## Extract the number of individuals in each compartment at the
## time-points in 'tspan'.
trajectory(result)

## Extract the number of recovered individuals in the first node
## at the time-points in 'tspan'.
trajectory(result, compartments = "R", index = 1)

## Extract the number of recovered individuals in the first and
## third node at the time-points in 'tspan'.
trajectory(result, compartments = "R", index = c(1, 3))

## Create an 'SISe' model with 6 nodes and initialize
## it to run over 10 days.
u0 <- data.frame(S = 100:105, I = 1:6)
model <- SISe(u0 = u0, tspan = 1:10, phi = rep(0, 6),
    upsilon = 0.02, gamma = 0.1, alpha = 1, epsilon = 1.1e-5,
    beta_t1 = 0.15, beta_t2 = 0.15, beta_t3 = 0.15, beta_t4 = 0.15,
    end_t1 = 91, end_t2 = 182, end_t3 = 273, end_t4 = 365)

## Run the model
result <- run(model)

## Extract the continuous state variable 'phi' which represents
## the environmental infectious pressure.
trajectory(result, "phi")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{trajectory,SimInf\_pfilter-method}{Extract filtered trajectory from running a particle filter}{trajectory,SimInf.Rul.pfilter.Rdash.method}
%
\begin{Description}
Extract filtered trajectory from running a particle filter
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pfilter'
trajectory(model, compartments, index, format = c("data.frame", "matrix"))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] the \code{SimInf\_pfilter} object to extract the
result from.

\item[\code{compartments}] specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. \code{compartments = c('S', 'I', 'R')},
or as a formula e.g. \code{compartments = \textasciitilde{}S+I+R} (see
`Examples'). Default (\code{compartments=NULL}) is to
extract the number of individuals in each compartment i.e. the
data from all discrete state compartments in the model. In
models that also have continuous state variables e.g. the
\code{SISe} model, they are also included.

\item[\code{index}] indices specifying the subset of nodes to include
when extracting data. Default (\code{index = NULL}) is to
extract data from all nodes.

\item[\code{format}] the default (\code{format = "data.frame"}) is to
generate a \code{data.frame} with one row per node and
time-step with the number of individuals in each
compartment. Using \code{format = "matrix"} returns the result
as a matrix, which is the internal format (see
`Details' in
\code{\LinkA{trajectory,SimInf\_model-method}{trajectory,SimInf.Rul.model.Rdash.method}}).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{data.frame} if \code{format = "data.frame"}, else
a matrix.
\end{Value}
\inputencoding{utf8}
\HeaderA{trajectory,SimInf\_pmcmc-method}{Extract filtered trajectories from fitting a PMCMC algorithm}{trajectory,SimInf.Rul.pmcmc.Rdash.method}
%
\begin{Description}
Extract filtered trajectories from a particle Markov chain Monte
Carlo algorithm.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 method for signature 'SimInf_pmcmc'
trajectory(model, compartments, index, start = 1, end = NULL, thin = 1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] the \code{SimInf\_pmcmc} object to extract the
filtered trajectories from.

\item[\code{compartments}] specify the names of the compartments to
extract data from. The compartments can be specified as a
character vector e.g. \code{compartments = c('S', 'I', 'R')},
or as a formula e.g. \code{compartments = \textasciitilde{}S+I+R} (see
`Examples'). Default (\code{compartments=NULL}) is to
extract the number of individuals in each compartment i.e. the
data from all discrete state compartments in the model. In
models that also have continuous state variables e.g. the
\code{SISe} model, they are also included.

\item[\code{index}] indices specifying the subset of nodes to include
when extracting data. Default (\code{index = NULL}) is to
extract data from all nodes.

\item[\code{start}] The start iteration to remove some burn-in
iterations. Default is \code{start = 1}.

\item[\code{end}] the last iteration to include. Default is \code{NULL}
which set \code{end} to the last iteration in the chain.

\item[\code{thin}] keep every \code{thin} iteration after the
\code{start} iteration. Default is \code{thin = 1}, i.e., keep
every iteration.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{data.frame} where the first column is the
\code{iteration} and the remaining columns are the result from
calling \code{\LinkA{trajectory,SimInf\_model-method}{trajectory,SimInf.Rul.model.Rdash.method}} with the
arguments \code{compartments} and \code{index} for each
iteration.
\end{Value}
\inputencoding{utf8}
\HeaderA{u0}{Get the initial compartment state}{u0}
\aliasA{u0,SimInf\_indiv\_events-method}{u0}{u0,SimInf.Rul.indiv.Rul.events.Rdash.method}
\aliasA{u0,SimInf\_model-method}{u0}{u0,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Get the initial compartment state
\end{Description}
%
\begin{Usage}
\begin{verbatim}
u0(object, ...)

## S4 method for signature 'SimInf_model'
u0(object, ...)

## S4 method for signature 'SimInf_indiv_events'
u0(object, time = NULL, target = NULL, age = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] The object to get the initial compartment state
\code{u0} from.

\item[\code{...}] Additional arguments.

\item[\code{time}] Only used when object is of class
\code{SimInf\_indiv\_events} object. The time-point that will be
used to create u0. If left empty (the default), the earliest
time among the events will be used.

\item[\code{target}] Only used when object is of class
\code{SimInf\_indiv\_events} object. The SimInf model ('SEIR',
'SIR', 'SIS', 'SISe3', 'SISe3\_sp', 'SISe', or 'SISe\_sp') to
target the events and u0 for. The default, \code{NULL},
creates an \code{u0}, but where the compartments might have to
be renamed and post-processed to fit the specific use case.

\item[\code{age}] Only used when object is of class
\code{SimInf\_indiv\_events} object. An integer vector with
break points in days for the ageing events. The default,
\code{NULL}, creates an \code{u0} where all individuals belong
to the same age category.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a \code{data.frame} with the initial compartment state.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model object.
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Get the initial compartment state.
u0(model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{u0<-}{Update the initial compartment state u0 in each node}{u0<.Rdash.}
\aliasA{u0<\Rdash{},SimInf\_model-method}{u0<-}{u0<.Rdash.,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Update the initial compartment state u0 in each node
\end{Description}
%
\begin{Usage}
\begin{verbatim}
u0(model) <- value

## S4 replacement method for signature 'SimInf_model'
u0(model) <- value
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The model to update the initial compartment state
\code{u0}.

\item[\code{value}] A \code{data.frame} with the initial state in each
node. Each row is one node, and the number of rows in
\code{u0} must match the number of nodes in \code{model}. Only
the columns in \code{u0} with a name that matches a
compartment in the \code{model} will be used.
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Create an SIR model object.
model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
             tspan = 1:100,
             beta = 0.16,
             gamma = 0.077)

## Run the SIR model and plot the result.
set.seed(22)
result <- run(model)
plot(result)

## Update u0 and run the model again
u0(model) <- data.frame(S = 990, I = 10, R = 0)
result <- run(model)
plot(result)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{u0\_SEIR}{Example data to initialize the `SEIR' model}{u0.Rul.SEIR}
%
\begin{Description}
Example data to initialize a population of 1600 nodes and
demonstrate the \code{\LinkA{SEIR}{SEIR.Rdash.class}} model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
u0_SEIR()
\end{verbatim}
\end{Usage}
%
\begin{Details}
A \code{data.frame} with the number of individuals in the
`S', `E', `I' and `R' compartments in
1600 nodes. Note that the `E', `I' and `R'
compartments are zero.
\end{Details}
%
\begin{Value}
A \code{data.frame}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SEIR' model with 1600 nodes and initialize it to
## run over 4*365 days and record data at weekly time-points.
## Add ten infected individuals to the first node.
u0 <- u0_SEIR()
u0$I[1] <- 10
tspan <- seq(from = 1, to = 4*365, by = 7)
model <- SEIR(u0      = u0,
              tspan   = tspan,
              events  = events_SEIR(),
              beta    = 0.16,
              epsilon = 0.25,
              gamma   = 0.01)

## Run the model to generate a single stochastic trajectory.
result <- run(model)
plot(result)

## Summarize trajectory
summary(result)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{u0\_SIR}{Example data to initialize the `SIR' model}{u0.Rul.SIR}
%
\begin{Description}
Example data to initialize a population of 1600 nodes and
demonstrate the \code{\LinkA{SIR}{SIR.Rdash.class}} model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
u0_SIR()
\end{verbatim}
\end{Usage}
%
\begin{Details}
A \code{data.frame} with the number of individuals in the
`S', `I' and `R' compartments in 1600
nodes. Note that the `I' and `R' compartments are
zero.
\end{Details}
%
\begin{Value}
A \code{data.frame}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIR' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 <- u0_SIR()
u0$I[1] <- 1
tspan <- seq(from = 1, to = 4*365, by = 1)
model <- SIR(u0     = u0,
             tspan  = tspan,
             events = events_SIR(),
             beta   = 0.16,
             gamma  = 0.01)

## Run the model to generate a single stochastic trajectory.
result <- run(model)
plot(result)

## Summarize trajectory
summary(result)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{u0\_SIS}{Example data to initialize the `SIS' model}{u0.Rul.SIS}
%
\begin{Description}
Example data to initialize a population of 1600 nodes and
demonstrate the \code{\LinkA{SIS}{SIS.Rdash.class}} model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
u0_SIS()
\end{verbatim}
\end{Usage}
%
\begin{Details}
A \code{data.frame} with the number of individuals in the
`S', and `I' compartments in 1600 nodes. Note that
the `I' compartment is zero.
\end{Details}
%
\begin{Value}
A \code{data.frame}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SIS' model with 1600 nodes and initialize
## it to run over 4*365 days. Add one infected individual
## to the first node.
u0 <- u0_SIS()
u0$I[1] <- 1
tspan <- seq(from = 1, to = 4*365, by = 1)
model <- SIS(u0     = u0,
             tspan  = tspan,
             events = events_SIS(),
             beta   = 0.16,
             gamma  = 0.01)

## Run the model to generate a single stochastic trajectory.
result <- run(model)
plot(result)

## Summarize trajectory
summary(result)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{u0\_SISe}{Example data to initialize the `SISe' model}{u0.Rul.SISe}
%
\begin{Description}
Example data to initialize a population of 1600 nodes and
demonstrate the \code{\LinkA{SISe}{SISe.Rdash.class}} model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
u0_SISe()
\end{verbatim}
\end{Usage}
%
\begin{Details}
A \code{data.frame} with the number of individuals in the
`S' and `I' compartments in 1600 nodes. Note that
the `I' compartment is zero.
\end{Details}
%
\begin{Value}
A \code{data.frame}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SISe' model with 1600 nodes and initialize it to
## run over 4*365 days and record data at weekly time-points.

## Load the initial population and add ten infected individuals to
## the first node.
u0 <- u0_SISe()
u0$I[1] <- 10

## Define 'tspan' to run the simulation over 4*365 and record the
## state of the system at weekly time-points.
tspan <- seq(from = 1, to = 4*365, by = 7)

## Load scheduled events for the population of nodes with births,
## deaths and between-node movements of individuals.
events <- events_SISe()

## Create an 'SISe' model
model <- SISe(u0 = u0, tspan = tspan, events = events_SISe(),
              phi = 0, upsilon = 1.8e-2, gamma = 0.1, alpha = 1,
              beta_t1 = 1.0e-1, beta_t2 = 1.0e-1, beta_t3 = 1.25e-1,
              beta_t4 = 1.25e-1, end_t1 = 91, end_t2 = 182,
              end_t3 = 273, end_t4 = 365, epsilon = 0)

## Run the model to generate a single stochastic trajectory.
result <- run(model)

## Summarize trajectory
summary(result)

## Plot the proportion of nodes with at least one infected
## individual.
plot(result, I~S+I, level = 2, type = "l")

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{u0\_SISe3}{Example data to initialize the `SISe3' model}{u0.Rul.SISe3}
\keyword{dataset}{u0\_SISe3}
%
\begin{Description}
Example data to initialize a population of 1600 nodes and
demonstrate the \code{\LinkA{SISe3}{SISe3.Rdash.class}} model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(u0_SISe3)
\end{verbatim}
\end{Usage}
%
\begin{Format}
A \code{data.frame}
\end{Format}
%
\begin{Details}
A \code{data.frame} with the number of individuals in the
`S\_1', `S\_2', `S\_3', `I\_1',
`I\_2' and `I\_3' compartments in 1600 nodes. Note
that the `I\_1', `I\_2' and `I\_3' compartments
are zero.
\end{Details}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## For reproducibility, call the set.seed() function and specify
## the number of threads to use. To use all available threads,
## remove the set_num_threads() call.
set.seed(123)
set_num_threads(1)

## Create an 'SISe3' model with 1600 nodes and initialize it to
## run over 4*365 days and record data at weekly time-points.

## Load the initial population and add ten infected individuals to
## I_1 in the first node.
u0 <- u0_SISe3
u0$I_1[1] <- 10

## Define 'tspan' to run the simulation over 4*365 and record the
## state of the system at weekly time-points.
tspan <- seq(from = 1, to = 4*365, by = 7)

## Load scheduled events for the population of nodes with births,
## deaths and between-node movements of individuals.
events <- events_SISe3

## Create a 'SISe3' model
model <- SISe3(u0 = u0, tspan = tspan, events = events,
               phi = rep(0, nrow(u0)), upsilon_1 = 1.8e-2,
               upsilon_2 = 1.8e-2, upsilon_3 = 1.8e-2,
               gamma_1 = 0.1, gamma_2 = 0.1, gamma_3 = 0.1,
               alpha = 1, beta_t1 = 1.0e-1, beta_t2 = 1.0e-1,
               beta_t3 = 1.25e-1, beta_t4 = 1.25e-1, end_t1 = 91,
               end_t2 = 182, end_t3 = 273, end_t4 = 365, epsilon = 0)

## Run the model to generate a single stochastic trajectory.
result <- run(model)

## Summarize trajectory
summary(result)

## Plot the proportion of nodes with at least one infected
## individual.
plot(result, I_1 + I_2 + I_3 ~ ., level = 2, type = "l")

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{v0<-}{Update the initial continuous state v0 in each node}{v0<.Rdash.}
\aliasA{v0<\Rdash{},SimInf\_model-method}{v0<-}{v0<.Rdash.,SimInf.Rul.model.Rdash.method}
%
\begin{Description}
Update the initial continuous state v0 in each node
\end{Description}
%
\begin{Usage}
\begin{verbatim}
v0(model) <- value

## S4 replacement method for signature 'SimInf_model'
v0(model) <- value
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] The model to update the initial continuous state
\code{v0}.

\item[\code{value}] the initial continuous state in each node. Must be a
\code{data.frame} or an object that can be coerced to a
\code{data.frame}. A named numeric vector will be coerced to a
one-row \code{data.frame}. Each row is one node, and the
number of rows in \code{v0} must match the number of nodes in
\code{model}. Only the columns in \code{v0} with a name that
matches a continuous state in \code{v0} in the \code{model}
will be used
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Create an 'SISe' model with no infected individuals and no
## infectious pressure (phi = 0, epsilon = 0).
model <- SISe(u0 = data.frame(S = 100, I = 0), tspan = 1:100,
              phi = 0, upsilon = 0.02, gamma = 0.1, alpha = 1,
              epsilon = 0, beta_t1 = 0.15, beta_t2 = 0.15,
              beta_t3 = 0.15, beta_t4 = 0.15, end_t1 = 91,
              end_t2 = 182, end_t3 = 273, end_t4 = 365)

## Run the 'SISe' model and plot the result.
set.seed(22)
result <- run(model)
plot(result)

## Update the infectious pressure 'phi' in 'v0' and run
## the model again.
v0(model) <- data.frame(phi = 1)
result <- run(model)
plot(result)
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
