
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "SimInf"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('SimInf')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("C_code")
> ### * C_code
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: C_code
> ### Title: Extract the C code from a 'SimInf_model' object
> ### Aliases: C_code
> 
> ### ** Examples
> 
> ## Use the model parser to create a 'SimInf_model' object that
> ## expresses an SIR model, where 'b' is the transmission rate and
> ## 'g' is the recovery rate.
> model <- mparse(transitions = c("S -> b*S*I/(S+I+R) -> I", "I -> g*I -> R"),
+                 compartments = c("S", "I", "R"),
+                 gdata = c(b = 0.16, g = 0.077),
+                 u0 = data.frame(S = 99, I = 1, R = 0),
+                 tspan = 1:10)
> 
> ## View the C code.
> C_code(model)
  [1] "/* Generated by SimInf (v9.8.1.9001) */"                            
  [2] ""                                                                   
  [3] "#include <R_ext/Rdynload.h>"                                        
  [4] "#include \"SimInf.h\""                                              
  [5] ""                                                                   
  [6] "/**"                                                                
  [7] " * Make sure the necessary macros are defined so that the"          
  [8] " * compiler can replace them when compiling the model."             
  [9] " * 'SIMINF_MODEL_RUN' defines the function name of the function"    
 [10] " * that will be called from R to run a trajectory of the model."    
 [11] " * 'SIMINF_R_INIT' is the name of the function that R will call"    
 [12] " * when this model is loaded into R. 'SIMINF_FORCE_SYMBOLS'"        
 [13] " * defines whether R allows the entry point for the run function"   
 [14] " * to be searched for as a character string."                       
 [15] " * If this file is compiled from SimInf (when calling run), the"    
 [16] " * macros are defined by SimInf before calling 'R CMD SHLIB'."      
 [17] " * If this file is compiled as part of a package, then the"         
 [18] " * definitions are set in the variable 'PKG_CPPFLAGS' in"           
 [19] " * 'src/Makevars' and 'src/Makevars.in'."                           
 [20] " */"                                                                
 [21] "#if !defined(SIMINF_MODEL_RUN)"                                     
 [22] "#  error Definition for 'SIMINF_MODEL_RUN' is missing."             
 [23] "#endif"                                                             
 [24] "#if !defined(SIMINF_R_INIT)"                                        
 [25] "#  error Definition for 'SIMINF_R_INIT' is missing."                
 [26] "#endif"                                                             
 [27] "#if !defined(SIMINF_FORCE_SYMBOLS)"                                 
 [28] "#  error Definition for 'SIMINF_FORCE_SYMBOLS' is missing."         
 [29] "#endif"                                                             
 [30] ""                                                                   
 [31] "/**"                                                                
 [32] " * @param u The compartment state vector in the node."              
 [33] " * @param v The continuous state vector in the node."               
 [34] " * @param ldata The local data vector in the node."                 
 [35] " * @param gdata The global data vector."                            
 [36] " * @param t Current time."                                          
 [37] " * @return propensity."                                             
 [38] " */"                                                                
 [39] "static double trFun1("                                              
 [40] "    const int *u,"                                                  
 [41] "    const double *v,"                                               
 [42] "    const double *ldata,"                                           
 [43] "    const double *gdata,"                                           
 [44] "    double t)"                                                      
 [45] "{"                                                                  
 [46] "    return gdata[0]*u[0]*u[1]/(u[0]+u[1]+u[2]);"                    
 [47] "}"                                                                  
 [48] ""                                                                   
 [49] "/**"                                                                
 [50] " * @param u The compartment state vector in the node."              
 [51] " * @param v The continuous state vector in the node."               
 [52] " * @param ldata The local data vector in the node."                 
 [53] " * @param gdata The global data vector."                            
 [54] " * @param t Current time."                                          
 [55] " * @return propensity."                                             
 [56] " */"                                                                
 [57] "static double trFun2("                                              
 [58] "    const int *u,"                                                  
 [59] "    const double *v,"                                               
 [60] "    const double *ldata,"                                           
 [61] "    const double *gdata,"                                           
 [62] "    double t)"                                                      
 [63] "{"                                                                  
 [64] "    return gdata[1]*u[1];"                                          
 [65] "}"                                                                  
 [66] ""                                                                   
 [67] "/**"                                                                
 [68] " * Post time step function."                                        
 [69] " *"                                                                 
 [70] " * @param v_new If a continuous state vector is used by a model,"   
 [71] " *        this is the new continuous state vector in the node after"
 [72] " *        the post time step."                                      
 [73] " * @param u The compartment state vector in the node."              
 [74] " * @param v The current continuous state vector in the node."       
 [75] " * @param ldata The local data vector in the node."                 
 [76] " * @param gdata The global data vector that is common to all nodes."
 [77] " * @param node The node index. Note the node index is zero-based,"  
 [78] " *        i.e., the first node is 0."                               
 [79] " * @param t Current time in the simulation."                        
 [80] " * @return error code (<0), or 1 if node needs to update the"       
 [81] " *         transition rates, or 0 when it doesn't need to update"   
 [82] " *         the transition rates."                                   
 [83] " */"                                                                
 [84] "static int ptsFun("                                                 
 [85] "    double *v_new,"                                                 
 [86] "    const int *u,"                                                  
 [87] "    const double *v,"                                               
 [88] "    const double *ldata,"                                           
 [89] "    const double *gdata,"                                           
 [90] "    int node,"                                                      
 [91] "    double t)"                                                      
 [92] "{"                                                                  
 [93] "    return 0;"                                                      
 [94] "}"                                                                  
 [95] ""                                                                   
 [96] "/**"                                                                
 [97] " * Run a trajectory of the model."                                  
 [98] " *"                                                                 
 [99] " * @param model The model."                                         
[100] " * @param solver The name of the numerical solver."                 
[101] " * @return A model with a trajectory attached to it."               
[102] " */"                                                                
[103] "static SEXP SIMINF_MODEL_RUN(SEXP model, SEXP solver)"              
[104] "{"                                                                  
[105] "    static SEXP(*SimInf_run)(SEXP, SEXP, TRFun*, PTSFun) = NULL;"   
[106] "    TRFun tr_fun[] = {&trFun1, &trFun2};"                           
[107] ""                                                                   
[108] "    if (!SimInf_run) {"                                             
[109] "        SimInf_run = (SEXP(*)(SEXP, SEXP, TRFun*, PTSFun))"         
[110] "            R_GetCCallable(\"SimInf\", \"SimInf_run\");"            
[111] ""                                                                   
[112] "        if (!SimInf_run) {"                                         
[113] "            Rf_error(\"Cannot find function 'SimInf_run'.\");"      
[114] "        }"                                                          
[115] "    }"                                                              
[116] ""                                                                   
[117] "    return SimInf_run(model, solver, tr_fun, &ptsFun);"             
[118] "}"                                                                  
[119] ""                                                                   
[120] "/**"                                                                
[121] " * A NULL-terminated array of routines to register for the .Call"   
[122] " * interface, see section '5.4 Registering native routines' in"     
[123] " * the 'Writing R Extensions' manual."                              
[124] " */"                                                                
[125] "static const R_CallMethodDef callMethods[] ="                       
[126] "{"                                                                  
[127] "    SIMINF_CALLDEF(SIMINF_MODEL_RUN, 2),"                           
[128] "    {NULL, NULL, 0}"                                                
[129] "};"                                                                 
[130] ""                                                                   
[131] "/**"                                                                
[132] " * This routine will be invoked when R loads the shared object/DLL,"
[133] " * see section '5.4 Registering native routines' in the"            
[134] " * 'Writing R Extensions' manual."                                  
[135] " */"                                                                
[136] "void SIMINF_R_INIT(DllInfo *info)"                                  
[137] "{"                                                                  
[138] "    R_registerRoutines(info, NULL, callMethods, NULL, NULL);"       
[139] "    R_useDynamicSymbols(info, FALSE);"                              
[140] "    R_forceSymbols(info, SIMINF_FORCE_SYMBOLS);"                    
[141] "}"                                                                  
> 
> 
> 
> cleanEx()
> nameEx("SEIR")
> ### * SEIR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SEIR
> ### Title: Create an SEIR model
> ### Aliases: SEIR
> 
> ### ** Examples
> 
> ## Create a SEIR model object.
> model <- SEIR(u0 = data.frame(S = 99, E = 0, I = 1, R = 0),
+               tspan = 1:100,
+               beta = 0.16,
+               epsilon = 0.25,
+               gamma = 0.077)
> 
> ## Run the SEIR model and plot the result.
> set.seed(3)
> result <- run(model)
> plot(result)
> 
> 
> 
> cleanEx()
> nameEx("SIR-class")
> ### * SIR-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SIR-class
> ### Title: Definition of the SIR model
> ### Aliases: SIR-class
> 
> ### ** Examples
> 
> ## Create an SIR model object.
> model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
+              tspan = 1:100,
+              beta = 0.16,
+              gamma = 0.077)
> 
> ## Run the SIR model and plot the result.
> set.seed(22)
> result <- run(model)
> plot(result)
> 
> 
> 
> cleanEx()
> nameEx("SIR")
> ### * SIR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SIR
> ### Title: Create an SIR model
> ### Aliases: SIR
> 
> ### ** Examples
> 
> ## Create an SIR model object.
> model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
+              tspan = 1:100,
+              beta = 0.16,
+              gamma = 0.077)
> 
> ## Run the SIR model and plot the result.
> set.seed(22)
> result <- run(model)
> plot(result)
> 
> 
> 
> cleanEx()
> nameEx("SIS-class")
> ### * SIS-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SIS-class
> ### Title: Definition of the SIS model
> ### Aliases: SIS-class
> 
> ### ** Examples
> 
> ## Create an SIS model object.
> model <- SIS(u0 = data.frame(S = 99, I = 1),
+              tspan = 1:100,
+              beta = 0.16,
+              gamma = 0.077)
> 
> ## Run the SIS model and plot the result.
> set.seed(22)
> result <- run(model)
> plot(result)
> 
> 
> 
> cleanEx()
> nameEx("SIS")
> ### * SIS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SIS
> ### Title: Create an SIS model
> ### Aliases: SIS
> 
> ### ** Examples
> 
> ## Create an SIS model object.
> model <- SIS(u0 = data.frame(S = 99, I = 1),
+              tspan = 1:100,
+              beta = 0.16,
+              gamma = 0.077)
> 
> ## Run the SIS model and plot the result.
> set.seed(22)
> result <- run(model)
> plot(result)
> 
> 
> 
> cleanEx()
> nameEx("SimInf_events")
> ### * SimInf_events
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SimInf_events
> ### Title: Create a 'SimInf_events' object
> ### Aliases: SimInf_events
> 
> ### ** Examples
> 
> ## Let us illustrate how movement events can be used to transfer
> ## individuals from one node to another.  Use the built-in SIR
> ## model and start with 2 nodes where all individuals are in the
> ## first node (100 per compartment).
> u0 <- data.frame(S = c(100, 0), I = c(100, 0), R = c(100, 0))
> 
> ## Then create 300 movement events to transfer all individuals,
> ## one per day, from the first node to the second node. Use the
> ## fourth column in the select matrix where all compartments
> ## can be sampled with equal weight.
> events <- data.frame(event      = rep("extTrans", 300),
+                      time       = 1:300,
+                      node       = 1,
+                      dest       = 2,
+                      n          = 1,
+                      proportion = 0,
+                      select     = 4,
+                      shift      = 0)
> 
> ## Create an SIR model without disease transmission to
> ## demonstrate the events.
> model <- SIR(u0      = u0,
+              tspan  = 1:300,
+              events = events,
+              beta   = 0,
+              gamma  = 0)
> 
> ## Run the model and plot the number of individuals in
> ## the second node.  As can be seen in the figure, all
> ## indivuduals have been moved to the second node when
> ## t = 300.
> plot(run(model), index = 1:2, range = FALSE)
> 
> ## Let us now double the weight to sample from the 'I'
> ## compartment and rerun the model.
> model@events@E[2, 4] <- 2
> plot(run(model), index = 1:2, range = FALSE)
> 
> ## And much larger weight to sample from the I compartment.
> model@events@E[2, 4] <- 10
> plot(run(model), index = 1:2, range = FALSE)
> 
> ## Increase the weight for the R compartment.
> model@events@E[3, 4] <- 4
> plot(run(model), index = 1:2, range = FALSE)
> 
> 
> 
> cleanEx()
> nameEx("abc")
> ### * abc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: abc
> ### Title: Approximate Bayesian computation
> ### Aliases: abc abc,SimInf_model-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Let us consider an SIR model in a closed population with N = 100
> ##D ## individuals of whom one is initially infectious and the rest are
> ##D ## susceptible. First, generate one realisation (with a specified
> ##D ## seed) from the model with known parameters \code{beta = 0.16} and
> ##D ## \code{gamma = 0.077}. Then, use \code{abc} to infer the (known)
> ##D ## parameters from the simulated data.
> ##D model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
> ##D              tspan = 1:100,
> ##D              beta = 0.16,
> ##D              gamma = 0.077)
> ##D 
> ##D ## Run the SIR model and plot the number of infectious.
> ##D set.seed(22)
> ##D infectious <- trajectory(run(model), "I")$I
> ##D plot(infectious, type = "s")
> ##D 
> ##D ## The distance function to accept or reject a proposal. Each node
> ##D ## in the simulated trajectory (contained in the 'result' object)
> ##D ## represents one proposal.
> ##D distance <- function(result, ...) {
> ##D     ## Extract the time-series of infectious in each node as a
> ##D     ## data.frame.
> ##D     sim <- trajectory(result, "I")
> ##D 
> ##D     ## Split the 'sim' data.frame by node and calculate the sum of the
> ##D     ## squared distance at each time-point for each node.
> ##D     dist <- tapply(sim$I, sim$node, function(sim_infectious) {
> ##D         sum((infectious - sim_infectious)^2)
> ##D     })
> ##D 
> ##D     ## Return the distance for each node. Each proposal will be
> ##D     ## accepted or rejected depending on if the distance is less than
> ##D     ## the tolerance for the current generation.
> ##D     dist
> ##D }
> ##D 
> ##D ## Fit the model parameters using ABC-SMC and adaptive tolerance
> ##D ## selection. The priors for the parameters are specified using a
> ##D ## formula notation. Here we use a uniform distribtion for each
> ##D ## parameter with lower bound = 0 and upper bound = 1. Note that we
> ##D ## use a low number particles here to keep the run-time of the example
> ##D ## short. In practice you would want to use many more to ensure better
> ##D ## approximations.
> ##D fit <- abc(model = model,
> ##D            priors = c(beta ~ uniform(0, 1), gamma ~ uniform(0, 1)),
> ##D            n_particles = 100,
> ##D            n_init = 1000,
> ##D            distance = distance,
> ##D            verbose = TRUE)
> ##D 
> ##D ## Print a brief summary.
> ##D fit
> ##D 
> ##D ## Display the ABC posterior distribution.
> ##D plot(fit)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("boxplot-SimInf_model-method")
> ### * boxplot-SimInf_model-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boxplot,SimInf_model-method
> ### Title: Box plot of number of individuals in each compartment
> ### Aliases: boxplot,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an 'SIR' model with 10 nodes and initialise
> ## it with 99 susceptible individuals and one infected
> ## individual. Let the model run over 100 days.
> model <- SIR(u0 = data.frame(S = rep(99, 10),
+                              I = rep(1, 10),
+                              R = rep(0, 10)),
+              tspan = 1:100,
+              beta = 0.16,
+              gamma = 0.077)
> 
> ## Run the model and save the result.
> result <- run(model)
> 
> ## Create a boxplot that includes all compartments in all nodes.
> boxplot(result)
> 
> ## Create a boxplot that includes the S and I compartments in
> ## nodes 1 and 2.
> boxplot(result, ~S+I, 1:2)
> 
> 
> 
> cleanEx()
> nameEx("distance_matrix")
> ### * distance_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distance_matrix
> ### Title: Create a distance matrix between nodes for spatial models
> ### Aliases: distance_matrix
> 
> ### ** Examples
> 
> ## Generate a grid 10 x 10 and place one node in each cell
> ## separated by 100m.
> nodes <- expand.grid(x = (0:9) * 100, y = (0:9) * 100)
> plot(y ~ x, nodes)
> 
> ## Define the cutoff to only include neighbors within 300m.
> d <- distance_matrix(x = nodes$x, y = nodes$y, cutoff = 300)
> 
> ## View the first 10 rows and columns in the distance matrix
> d[1:10, 1:10]
10 x 10 sparse Matrix of class "dgCMatrix"
                                             
 [1,]   . 100 200 300   .   .   .   .   .   .
 [2,] 100   . 100 200 300   .   .   .   .   .
 [3,] 200 100   . 100 200 300   .   .   .   .
 [4,] 300 200 100   . 100 200 300   .   .   .
 [5,]   . 300 200 100   . 100 200 300   .   .
 [6,]   .   . 300 200 100   . 100 200 300   .
 [7,]   .   .   . 300 200 100   . 100 200 300
 [8,]   .   .   .   . 300 200 100   . 100 200
 [9,]   .   .   .   .   . 300 200 100   . 100
[10,]   .   .   .   .   .   . 300 200 100   .
> 
> 
> 
> cleanEx()
> nameEx("edge_properties_to_matrix")
> ### * edge_properties_to_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edge_properties_to_matrix
> ### Title: Convert an edge list with properties to a matrix
> ### Aliases: edge_properties_to_matrix
> 
> ### ** Examples
> 
> ## Let us consider the following edge properties.
> edges <- data.frame(
+     from  = c(  2,    3,     4,  1,   4,    5,   1,   3,   1,   3),
+     to    = c(  1,    1,     1,  2,   3,    3,   4,   4,   5,   5),
+     rate  = c(0.2, 0.01,  0.79,  1, 0.2, 0.05, 0.2, 0.8, 0.2, 0.8),
+     count = c(  5,    5,     5, 50,  10,   10,   5,   5,   5,   5))
> 
> ## Converting the edge properties into a matrix
> edge_properties_to_matrix(edges, 6)
       [,1] [,2]  [,3] [,4] [,5] [,6]
 [1,]  1.00    0  3.00  0.0  0.0   -1
 [2,]  0.20    1  0.20  0.2  0.2  NaN
 [3,]  5.00   50 10.00  5.0  5.0  NaN
 [4,]  2.00   -1  4.00  2.0  2.0  NaN
 [5,]  0.01  NaN  0.05  0.8  0.8  NaN
 [6,]  5.00  NaN 10.00  5.0  5.0  NaN
 [7,]  3.00  NaN -1.00 -1.0 -1.0  NaN
 [8,]  0.79  NaN   NaN  NaN  NaN  NaN
 [9,]  5.00  NaN   NaN  NaN  NaN  NaN
[10,] -1.00  NaN   NaN  NaN  NaN  NaN
> 
> ## Gives the following output. The first column contains first the
> ## properties for the edge from = 2 --> to = 1, where the first
> ## row is the zero-based index of from, i.e., 1. The second row
> ## contains the rate=0.2 and the third row count=5. On the fourth
> ## row starts the next sequence with the values in the second row
> ## in the edges data.frame. The stop value in the first column is
> ## on row 10. As can be seen in column 6, there are no edge
> ## properties for node=6.
> ##        [,1] [,2]  [,3] [,4] [,5] [,6]
> ##  [1,]  1.00    0  3.00  0.0  0.0   -1
> ##  [2,]  0.20    1  0.20  0.2  0.2  NaN
> ##  [3,]  5.00   50 10.00  5.0  5.0  NaN
> ##  [4,]  2.00   -1  4.00  2.0  2.0  NaN
> ##  [5,]  0.01  NaN  0.05  0.8  0.8  NaN
> ##  [6,]  5.00  NaN 10.00  5.0  5.0  NaN
> ##  [7,]  3.00  NaN -1.00 -1.0 -1.0  NaN
> ##  [8,]  0.79  NaN   NaN  NaN  NaN  NaN
> ##  [9,]  5.00  NaN   NaN  NaN  NaN  NaN
> ## [10,] -1.00  NaN   NaN  NaN  NaN  NaN
> 
> 
> 
> cleanEx()
> nameEx("events")
> ### * events
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: events
> ### Title: Extract the events from a 'SimInf_model' object
> ### Aliases: events events,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an SIR model that includes scheduled events.
> model <- SIR(u0     = u0_SIR(),
+              tspan  = 1:(4 * 365),
+              events = events_SIR(),
+              beta   = 0.16,
+              gamma  = 0.077)
> 
> ## Extract the scheduled events from the model and display summary
> summary(events(model))
Number of scheduled events: 466692
 - Exit: 182535 (n: min = 1 max = 1 avg = 1.0)
 - Enter: 182685 (n: min = 1 max = 1 avg = 1.0)
 - Internal transfer: 0
 - External transfer: 101472 (n: min = 1 max = 1 avg = 1.0)
> 
> ## Extract the scheduled events from the model and plot them
> plot(events(model))
> 
> 
> 
> cleanEx()
> nameEx("events_SEIR")
> ### * events_SEIR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: events_SEIR
> ### Title: Example data to initialize events for the 'SEIR' model
> ### Aliases: events_SEIR
> 
> ### ** Examples
> 
> ## For reproducibility, call the set.seed() function and specify
> ## the number of threads to use. To use all available threads,
> ## remove the set_num_threads() call.
> set.seed(123)
> set_num_threads(1)
> 
> ## Create an 'SEIR' model with 1600 nodes and initialize
> ## it to run over 4*365 days. Add one infected individual
> ## to the first node.
> u0 <- u0_SEIR()
> u0$I[1] <- 1
> tspan <- seq(from = 1, to = 4*365, by = 1)
> model <- SEIR(u0      = u0,
+               tspan   = tspan,
+               events  = events_SEIR(),
+               beta    = 0.16,
+               epsilon = 0.25,
+               gamma   = 0.01)
> 
> ## Display the number of individuals affected by each event type
> ## per day.
> plot(events(model))
> 
> ## Run the model to generate a single stochastic trajectory.
> result <- run(model)
> plot(result)
> 
> ## Summarize the trajectory. The summary includes the number of
> ## events by event type.
> summary(result)
Model: SEIR
Number of nodes: 1600

Transitions
-----------
 S -> beta*S*I/(S+E+I+R) -> E
 E -> epsilon*E -> I
 I -> gamma*I -> R

Global data
-----------
 Number of parameters without a name: 0
 - None

Local data
----------
 Parameter Value
 beta      0.16 
 epsilon   0.25 
 gamma     0.01 

Scheduled events
----------------
 Exit: 182535
 Enter: 182685
 Internal transfer: 0
 External transfer: 101472

Network summary
---------------
            Min. 1st Qu. Median Mean 3rd Qu. Max.
 Indegree:  40.0    57.0   62.0 62.1    68.0 90.0
 Outdegree: 36.0    57.0   62.0 62.1    67.0 89.0

Compartments
------------
      Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
 S   0.000   5.000  13.000  55.083 111.000 221.000
 E   0.000   0.000   0.000   0.479   0.000  34.000
 I   0.000   0.000   4.000  10.865  11.000 165.000
 R   0.000   0.000  63.000  58.098 105.000 218.000
> 
> 
> 
> cleanEx()
> nameEx("events_SIR")
> ### * events_SIR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: events_SIR
> ### Title: Example data to initialize events for the 'SIR' model
> ### Aliases: events_SIR
> 
> ### ** Examples
> 
> ## For reproducibility, call the set.seed() function and specify
> ## the number of threads to use. To use all available threads,
> ## remove the set_num_threads() call.
> set.seed(123)
> set_num_threads(1)
> 
> ## Create an 'SIR' model with 1600 nodes and initialize
> ## it to run over 4*365 days. Add one infected individual
> ## to the first node.
> u0 <- u0_SIR()
> u0$I[1] <- 1
> tspan <- seq(from = 1, to = 4*365, by = 1)
> model <- SIR(u0     = u0,
+              tspan  = tspan,
+              events = events_SIR(),
+              beta   = 0.16,
+              gamma  = 0.01)
> 
> ## Display the number of individuals affected by each event type
> ## per day.
> plot(events(model))
> 
> ## Run the model to generate a single stochastic trajectory.
> result <- run(model)
> plot(result)
> 
> ## Summarize the trajectory. The summary includes the number of
> ## events by event type.
> summary(result)
Model: SIR
Number of nodes: 1600

Transitions
-----------
 S -> beta*S*I/(S+I+R) -> I
 I -> gamma*I -> R

Global data
-----------
 Number of parameters without a name: 0
 - None

Local data
----------
 Parameter Value
 beta      0.16 
 gamma     0.01 

Scheduled events
----------------
 Exit: 182535
 Enter: 182685
 Internal transfer: 0
 External transfer: 101472

Network summary
---------------
            Min. 1st Qu. Median Mean 3rd Qu. Max.
 Indegree:  40.0    57.0   62.0 62.1    68.0 90.0
 Outdegree: 36.0    57.0   62.0 62.1    67.0 89.0

Compartments
------------
    Min. 1st Qu. Median  Mean 3rd Qu.  Max.
 S   0.0     5.0   13.0  55.6   112.0 219.0
 I   0.0     0.0    4.0  10.9    11.0 168.0
 R   0.0     0.0   62.0  58.0   105.0 221.0
> 
> 
> 
> cleanEx()
> nameEx("events_SIS")
> ### * events_SIS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: events_SIS
> ### Title: Example data to initialize events for the 'SIS' model
> ### Aliases: events_SIS
> 
> ### ** Examples
> 
> ## For reproducibility, call the set.seed() function and specify
> ## the number of threads to use. To use all available threads,
> ## remove the set_num_threads() call.
> set.seed(123)
> set_num_threads(1)
> 
> ## Create an 'SIS' model with 1600 nodes and initialize
> ## it to run over 4*365 days. Add one infected individual
> ## to the first node.
> u0 <- u0_SIS()
> u0$I[1] <- 1
> tspan <- seq(from = 1, to = 4*365, by = 1)
> model <- SIS(u0     = u0,
+              tspan  = tspan,
+              events = events_SIS(),
+              beta   = 0.16,
+              gamma  = 0.01)
> 
> ## Display the number of individuals affected by each event type
> ## per day.
> plot(events(model))
> 
> ## Run the model to generate a single stochastic trajectory.
> result <- run(model)
> plot(result)
> 
> ## Summarize the trajectory. The summary includes the number of
> ## events by event type.
> summary(result)
Model: SIS
Number of nodes: 1600

Transitions
-----------
 S -> upsilon*S*I -> I
 I -> gamma*I -> S

Global data
-----------
 Number of parameters without a name: 0
 - None

Local data
----------
 Parameter Value
 beta      0.16 
 gamma     0.01 

Scheduled events
----------------
 Exit: 182535
 Enter: 182685
 Internal transfer: 0
 External transfer: 101472

Network summary
---------------
            Min. 1st Qu. Median Mean 3rd Qu. Max.
 Indegree:  40.0    57.0   62.0 62.1    68.0 90.0
 Outdegree: 36.0    57.0   62.0 62.1    67.0 89.0

Compartments
------------
    Min. 1st Qu. Median  Mean 3rd Qu.  Max.
 S   0.0     7.0   10.0  44.2    96.0 218.0
 I   0.0     0.0   96.0  80.3   125.0 228.0
> 
> 
> 
> cleanEx()
> nameEx("events_SISe")
> ### * events_SISe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: events_SISe
> ### Title: Example data to initialize events for the 'SISe' model
> ### Aliases: events_SISe
> 
> ### ** Examples
> 
> ## For reproducibility, call the set.seed() function and specify
> ## the number of threads to use. To use all available threads,
> ## remove the set_num_threads() call.
> set.seed(123)
> set_num_threads(1)
> 
> ## Create an 'SISe' model with 1600 nodes and initialize
> ## it to run over 4*365 days. Add one infected individual
> ## to the first node.
> u0 <- u0_SISe()
> u0$I[1] <- 1
> tspan <- seq(from = 1, to = 4*365, by = 1)
> model <- SISe(u0 = u0, tspan = tspan, events = events_SISe(),
+               phi = 0, upsilon = 1.8e-2, gamma = 0.1, alpha = 1,
+               beta_t1 = 1.0e-1, beta_t2 = 1.0e-1, beta_t3 = 1.25e-1,
+               beta_t4 = 1.25e-1, end_t1 = 91, end_t2 = 182,
+               end_t3 = 273, end_t4 = 365, epsilon = 0)
> 
> ## Display the number of individuals affected by each event type
> ## per day.
> plot(events(model))
> 
> ## Run the model to generate a single stochastic trajectory.
> result <- run(model)
> 
> ## Summarize the trajectory. The summary includes the number of
> ## events by event type.
> summary(result)
Model: SISe
Number of nodes: 1600

Transitions
-----------
 S -> upsilon*phi*S -> I
 I -> gamma*I -> S

Global data
-----------
 Parameter Value
 upsilon   0.018
 gamma     0.100
 alpha     1.000
 beta_t1   0.100
 beta_t2   0.100
 beta_t3   0.125
 beta_t4   0.125
 epsilon   0.000

Local data
----------
 Parameter Value
 end_t1     91  
 end_t2    182  
 end_t3    273  
 end_t4    365  

Scheduled events
----------------
 Exit: 182535
 Enter: 182685
 Internal transfer: 0
 External transfer: 101472

Network summary
---------------
            Min. 1st Qu. Median Mean 3rd Qu. Max.
 Indegree:  40.0    57.0   62.0 62.1    68.0 90.0
 Outdegree: 36.0    57.0   62.0 62.1    67.0 89.0

Continuous state variables
--------------------------
         Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
 phi 0.00e+00 0.00e+00 0.00e+00 8.92e-08 0.00e+00 1.88e-02

Compartments
------------
       Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
 S 1.80e+01 1.01e+02 1.22e+02 1.25e+02 1.46e+02 2.37e+02
 I 0.00e+00 0.00e+00 0.00e+00 1.28e-06 0.00e+00 1.00e+00
> 
> 
> 
> cleanEx()
> nameEx("events_SISe3")
> ### * events_SISe3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: events_SISe3
> ### Title: Example data to initialize events for the 'SISe3' model
> ### Aliases: events_SISe3
> ### Keywords: dataset
> 
> ### ** Examples
> 
> ## For reproducibility, call the set.seed() function and specify
> ## the number of threads to use. To use all available threads,
> ## remove the set_num_threads() call.
> set.seed(123)
> set_num_threads(1)
> 
> ## Create an 'SISe3' model with 1600 nodes and initialize
> ## it to run over 4*365 days. Add one infected individual
> ## to the first node.
> data("u0_SISe3", package = "SimInf")
> data("events_SISe3", package = "SimInf")
> u0_SISe3$I_1[1] <- 1
> tspan <- seq(from = 1, to = 4*365, by = 1)
> model <- SISe3(u0 = u0_SISe3, tspan = tspan, events = events_SISe3,
+                phi = rep(0, nrow(u0_SISe3)), upsilon_1 = 1.8e-2,
+                upsilon_2 = 1.8e-2, upsilon_3 = 1.8e-2,
+                gamma_1 = 0.1, gamma_2 = 0.1, gamma_3 = 0.1,
+                alpha = 1, beta_t1 = 1.0e-1, beta_t2 = 1.0e-1,
+                beta_t3 = 1.25e-1, beta_t4 = 1.25e-1, end_t1 = 91,
+                end_t2 = 182, end_t3 = 273, end_t4 = 365, epsilon = 0)
> 
> ## Display the number of individuals affected by each event type
> ## per day.
> plot(events(model))
> 
> ## Run the model to generate a single stochastic trajectory.
> result <- run(model)
> 
> ## Summarize the trajectory. The summary includes the number of
> ## events by event type.
> summary(result)
Model: SISe3
Number of nodes: 1600

Transitions
-----------
 S_1 -> upsilon_1*phi*S_1 -> I_1
 I_1 -> gamma_1*I_1 -> S_1
 S_2 -> upsilon_2*phi*S_2 -> I_2
 I_2 -> gamma_2*I_2 -> S_2
 S_3 -> upsilon_3*phi*S_3 -> I_3
 I_3 -> gamma_3*I_3 -> S_3

Global data
-----------
 Parameter Value
 upsilon_1 0.018
 upsilon_2 0.018
 upsilon_3 0.018
 gamma_1   0.100
 gamma_2   0.100
 gamma_3   0.100
 alpha     1.000
 beta_t1   0.100
 beta_t2   0.100
 beta_t3   0.125
 beta_t4   0.125
 epsilon   0.000

Local data
----------
 Parameter Value
 end_t1     91  
 end_t2    182  
 end_t3    273  
 end_t4    365  

Scheduled events
----------------
 Exit: 182535
 Enter: 182685
 Internal transfer: 317081
 External transfer: 101472

Network summary
---------------
            Min. 1st Qu. Median Mean 3rd Qu. Max.
 Indegree:  40.0    57.0   62.0 62.1    68.0 90.0
 Outdegree: 36.0    57.0   62.0 62.1    67.0 89.0

Continuous state variables
--------------------------
         Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
 phi 0.00e+00 0.00e+00 0.00e+00 8.92e-08 0.00e+00 1.88e-02

Compartments
------------
         Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
 S_1 0.00e+00 7.00e+00 9.00e+00 9.23e+00 1.20e+01 3.00e+01
 I_1 0.00e+00 0.00e+00 0.00e+00 1.28e-06 0.00e+00 1.00e+00
 S_2 0.00e+00 1.40e+01 1.80e+01 1.80e+01 2.20e+01 4.30e+01
 I_2 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00
 S_3 0.00e+00 7.50e+01 9.40e+01 9.73e+01 1.19e+02 2.06e+02
 I_3 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00
> 
> 
> 
> cleanEx()
> nameEx("gdata-set")
> ### * gdata-set
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gdata<-
> ### Title: Set a global data parameter for a 'SimInf_model' object
> ### Aliases: gdata<- gdata<-,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an SIR model
> model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
+              tspan = 1:5, beta = 0.16, gamma = 0.077)
> 
> ## Set 'beta' to a new value
> gdata(model, "beta") <- 2
> 
> ## Extract the global data vector that is common to all nodes
> gdata(model)
beta 
   2 
> 
> 
> 
> cleanEx()
> nameEx("gdata")
> ### * gdata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gdata
> ### Title: Extract global data from a 'SimInf_model' object
> ### Aliases: gdata gdata,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an SIR model
> model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
+              tspan = 1:5, beta = 0.16, gamma = 0.077)
> 
> ## Set 'beta' to a new value
> gdata(model, "beta") <- 2
> 
> ## Extract the global data vector that is common to all nodes
> gdata(model)
beta 
   2 
> 
> 
> 
> cleanEx()
> nameEx("indegree")
> ### * indegree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: indegree
> ### Title: Determine in-degree for each node in a model
> ### Aliases: indegree
> 
> ### ** Examples
> 
> ## Create an 'SIR' model with 1600 nodes and initialize
> ## it with example data.
> model <- SIR(u0 = u0_SIR(), tspan = 1:1460, events = events_SIR(),
+              beta   = 0.16, gamma  = 0.077)
> 
> ## Display indegree for each node in the model.
> plot(indegree(model))
> 
> 
> 
> cleanEx()
> nameEx("ldata")
> ### * ldata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ldata
> ### Title: Extract local data from a node
> ### Aliases: ldata ldata,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an 'SISe' model with 1600 nodes.
> model <- SISe(u0 = u0_SISe(), tspan = 1:100, events = events_SISe(),
+               phi = 0, upsilon = 1.8e-2, gamma = 0.1, alpha = 1,
+               beta_t1 = 1.0e-1, beta_t2 = 1.0e-1, beta_t3 = 1.25e-1,
+               beta_t4 = 1.25e-1, end_t1 = c(91, 101), end_t2 = c(182, 185),
+               end_t3 = c(273, 275), end_t4 = c(365, 360), epsilon = 0)
> 
> ## Display local data from the first two nodes.
> ldata(model, node = 1)
end_t1 end_t2 end_t3 end_t4 
    91    182    273    365 
> ldata(model, node = 2)
end_t1 end_t2 end_t3 end_t4 
   101    185    275    360 
> 
> 
> 
> cleanEx()
> nameEx("mparse")
> ### * mparse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mparse
> ### Title: Model parser to define new models to run in 'SimInf'
> ### Aliases: mparse
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Use the model parser to create a 'SimInf_model' object that
> ##D ## expresses the SIR model, where 'beta' is the transmission rate
> ##D ## and 'gamma' is the recovery rate.
> ##D model  <- mparse(transitions = c("S -> beta*S*I/N -> I",
> ##D                                  "I -> gamma*I -> R",
> ##D                                  "N <- S+I+R"),
> ##D                  compartments = c("S", "I", "R"),
> ##D                  gdata = c(beta = 0.16, gamma = 0.077),
> ##D                  u0 = data.frame(S = 100, I = 1, R = 0),
> ##D                  tspan = 1:100)
> ##D 
> ##D ## Run and plot the result
> ##D set.seed(22)
> ##D result <- run(model)
> ##D plot(result)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("n_compartments")
> ### * n_compartments
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: n_compartments
> ### Title: Determine the number of compartments in a model
> ### Aliases: n_compartments n_compartments,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an 'SIR' model with 100 nodes, with 99 susceptible,
> ## 1 infected and 0 recovered in each node.
> u0 <- data.frame(S = rep(99, 100), I = rep(1, 100), R = rep(0, 100))
> model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)
> 
> ## Display the number of compartments in the model.
> n_compartments(model)
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("n_nodes")
> ### * n_nodes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: n_nodes
> ### Title: Determine the number of nodes in a model
> ### Aliases: n_nodes n_nodes,SimInf_model-method
> ###   n_nodes,SimInf_pfilter-method n_nodes,SimInf_pmcmc-method
> 
> ### ** Examples
> 
> ## Create an 'SIR' model with 100 nodes, with 99 susceptible,
> ## 1 infected and 0 recovered in each node.
> u0 <- data.frame(S = rep(99, 100), I = rep(1, 100), R = rep(0, 100))
> model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)
> 
> ## Display the number of nodes in the model.
> n_nodes(model)
[1] 100
> 
> 
> 
> cleanEx()
> nameEx("n_replicates")
> ### * n_replicates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: n_replicates
> ### Title: Determine the number of replicates in a model
> ### Aliases: n_replicates n_replicates,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an 'SIR' model with 100 nodes, with 99 susceptible,
> ## 1 infected and 0 recovered in each node.
> u0 <- data.frame(S = rep(99, 100), I = rep(1, 100), R = rep(0, 100))
> model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)
> 
> ## Display the number of replicates in the model.
> n_replicates(model)
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("nodes")
> ### * nodes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nodes
> ### Title: Example data with spatial distribution of nodes
> ### Aliases: nodes
> ### Keywords: dataset
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## For reproducibility, call the set.seed() function and specify
> ##D ## the number of threads to use. To use all available threads,
> ##D ## remove the set_num_threads() call.
> ##D set.seed(123)
> ##D set_num_threads(1)
> ##D 
> ##D ## Create an 'SIR' model with 1600 nodes and initialize
> ##D ## it to run over 4*365 days. Add one infected individual
> ##D ## to the first node.
> ##D u0 <- u0_SIR()
> ##D u0$I[1] <- 1
> ##D tspan <- seq(from = 1, to = 4*365, by = 1)
> ##D model <- SIR(u0     = u0,
> ##D              tspan  = tspan,
> ##D              events = events_SIR(),
> ##D              beta   = 0.16,
> ##D              gamma  = 0.077)
> ##D 
> ##D ## Run the model to generate a single stochastic trajectory.
> ##D result <- run(model)
> ##D 
> ##D ## Determine nodes with one or more infected individuals in the
> ##D ## trajectory. Extract the 'I' compartment and check for any
> ##D ## infected individuals in each node.
> ##D infected <- colSums(trajectory(result, ~ I, format = "matrix")) > 0
> ##D 
> ##D ## Display infected nodes in 'blue' and non-infected nodes in 'yellow'.
> ##D data("nodes", package = "SimInf")
> ##D col <- ifelse(infected, "blue", "yellow")
> ##D plot(y ~ x, nodes, col = col, pch = 20, cex = 2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("outdegree")
> ### * outdegree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: outdegree
> ### Title: Determine out-degree for each node in a model
> ### Aliases: outdegree
> 
> ### ** Examples
> 
> ## Create an 'SIR' model with 1600 nodes and initialize
> ## it with example data.
> model <- SIR(u0 = u0_SIR(), tspan = 1:1460, events = events_SIR(),
+              beta   = 0.16, gamma  = 0.077)
> 
> ## Display outdegree for each node in the model.
> plot(outdegree(model))
> 
> 
> 
> cleanEx()
> nameEx("pairs-SimInf_model-method")
> ### * pairs-SimInf_model-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairs,SimInf_model-method
> ### Title: Scatterplot of number of individuals in each compartment
> ### Aliases: pairs,SimInf_model-method
> 
> ### ** Examples
> 
> ## For reproducibility, call the set.seed() function and specify
> ## the number of threads to use. To use all available threads,
> ## remove the set_num_threads() call.
> set.seed(123)
> set_num_threads(1)
> 
> ## Create an 'SIR' model with 10 nodes and initialise
> ## it with 99 susceptible individuals and one infected
> ## individual. Let the model run over 100 days.
> model <- SIR(u0 = data.frame(S = rep(99, 10),
+                              I = rep(1, 10),
+                              R = rep(0, 10)),
+              tspan = 1:100,
+              beta = 0.16,
+              gamma = 0.077)
> 
> ## Run the model and save the result.
> result <- run(model)
> 
> ## Create a scatter plot that includes all compartments in all
> ## nodes.
> pairs(result)
> 
> ## Create a scatter plot that includes the S and I compartments in
> ## nodes 1 and 2.
> pairs(result, ~S+I, 1:2)
> 
> 
> 
> cleanEx()
> nameEx("pfilter")
> ### * pfilter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pfilter
> ### Title: Bootstrap particle filter
> ### Aliases: pfilter pfilter,SimInf_model-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Let us consider an SIR model in a closed population with N = 100
> ##D ## individuals of whom one is initially infectious and the rest are
> ##D ## susceptible. First, generate one realisation (with a specified
> ##D ## seed) from the model with known parameters 'beta = 0.16' and
> ##D ## 'gamma = 0.077'. Then, use 'pfilter' to apply the bootstrap
> ##D ## particle algorithm on the simulated data.
> ##D model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
> ##D              tspan = seq(1, 100, by = 3),
> ##D              beta = 0.16,
> ##D              gamma = 0.077)
> ##D 
> ##D ## Run the SIR model to generate simulated observed data for the
> ##D ## number of infected individuals.
> ##D set.seed(22)
> ##D infected <- trajectory(run(model), "I")[, c("time", "I")]
> ##D colnames(infected) <- c("time", "Iobs")
> ##D 
> ##D ## Use a Poison observation process for the infected individuals, such
> ##D ## that 'Iobs ~ poison(I + 1e-6)'. A small constant '1e-6' is added to
> ##D ## prevent numerical errors, since the simulated counts 'I' could be
> ##D ## zero, which would result in the Poisson rate parameter being zero,
> ##D ## which violates the conditions of the Poisson distribution. Use 1000
> ##D ## particles.
> ##D pf <- pfilter(model,
> ##D               obs_process = Iobs ~ poisson(I + 1e-6),
> ##D               data = infected,
> ##D               n_particles = 1000)
> ##D 
> ##D ## Print a brief summary.
> ##D pf
> ##D 
> ##D ## Compare the number infected 'I' in the filtered trajectory with the
> ##D ## infected 'Iobs' in the observed data.
> ##D plot(pf, ~I)
> ##D lines(Iobs ~ time, infected, col = "blue", lwd = 2, type = "s")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plot")
> ### * plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot,SimInf_model-method
> ### Title: Display the outcome from a simulated trajectory
> ### Aliases: plot,SimInf_model-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## For reproducibility, call the set.seed() function and specify
> ##D ## the number of threads to use. To use all available threads,
> ##D ## remove the set_num_threads() call.
> ##D set.seed(123)
> ##D set_num_threads(1)
> ##D 
> ##D ## Create an 'SIR' model with 100 nodes and initialise
> ##D ## it with 990 susceptible individuals and 10 infected
> ##D ## individuals in each node. Run the model over 100 days.
> ##D model <- SIR(u0 = data.frame(S = rep(990, 100),
> ##D                              I = rep(10, 100),
> ##D                              R = rep(0, 100)),
> ##D              tspan = 1:100,
> ##D              beta = 0.16,
> ##D              gamma = 0.077)
> ##D 
> ##D ## Run the model and save the result.
> ##D result <- run(model)
> ##D 
> ##D ## Plot the median and interquartile range of the number
> ##D ## of susceptible, infected and recovered individuals.
> ##D plot(result)
> ##D 
> ##D ## Plot the median and the middle 95\##D 
> ##D ## number of susceptible, infected and recovered individuals.
> ##D plot(result, range = 0.95)
> ##D 
> ##D ## Plot the median and interquartile range of the  number
> ##D ## of infected individuals.
> ##D plot(result, "I")
> ##D 
> ##D ## Use the formula notation instead to plot the median and
> ##D ## interquartile range of the number of infected individuals.
> ##D plot(result, ~I)
> ##D 
> ##D ## Plot the number of susceptible, infected
> ##D ## and recovered individuals in the first
> ##D ## three nodes.
> ##D plot(result, index = 1:3, range = FALSE)
> ##D 
> ##D ## Use plot type line instead.
> ##D plot(result, index = 1:3, range = FALSE, type = "l")
> ##D 
> ##D ## Plot the number of infected individuals in the first node.
> ##D plot(result, "I", index = 1, range = FALSE)
> ##D 
> ##D ## Plot the proportion of infected individuals (cases)
> ##D ## in the population.
> ##D plot(result, I ~ S + I + R)
> ##D 
> ##D ## Plot the proportion of nodes with infected individuals.
> ##D plot(result, I ~ S + I + R, level = 2)
> ##D 
> ##D ## Plot the median and interquartile range of the proportion
> ##D ## of infected individuals in each node
> ##D plot(result, I ~ S + I + R, level = 3)
> ##D 
> ##D ## Plot the proportion of infected individuals in the first
> ##D ## three nodes.
> ##D plot(result, I ~ S + I + R, level = 3, index = 1:3, range = FALSE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("prevalence-SimInf_model-method")
> ### * prevalence-SimInf_model-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prevalence,SimInf_model-method
> ### Title: Calculate prevalence from a model object with trajectory data
> ### Aliases: prevalence,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an 'SIR' model with 6 nodes and initialize
> ## it to run over 10 days.
> u0 <- data.frame(S = 100:105, I = c(0, 1, 0, 2, 0, 3), R = rep(0, 6))
> model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)
> 
> ## Run the model to generate a single stochastic trajectory.
> result <- run(model)
> 
> ## Determine the proportion of infected individuals (cases)
> ## in the population at the time-points in 'tspan'.
> prevalence(result, I ~ S + I + R)
   time  prevalence
1     1 0.009661836
2     2 0.009661836
3     3 0.008051530
4     4 0.006441224
5     5 0.004830918
6     6 0.004830918
7     7 0.003220612
8     8 0.003220612
9     9 0.004830918
10   10 0.004830918
> 
> ## Identical result is obtained with the shorthand 'I~.'
> prevalence(result, I ~ .)
   time  prevalence
1     1 0.009661836
2     2 0.009661836
3     3 0.008051530
4     4 0.006441224
5     5 0.004830918
6     6 0.004830918
7     7 0.003220612
8     8 0.003220612
9     9 0.004830918
10   10 0.004830918
> 
> ## Determine the proportion of nodes with infected individuals at
> ## the time-points in 'tspan'.
> prevalence(result, I ~ S + I + R, level = 2)
   time prevalence
1     1  0.5000000
2     2  0.5000000
3     3  0.5000000
4     4  0.5000000
5     5  0.5000000
6     6  0.5000000
7     7  0.3333333
8     8  0.3333333
9     9  0.3333333
10   10  0.3333333
> 
> ## Determine the proportion of infected individuals in each node
> ## at the time-points in 'tspan'.
> prevalence(result, I ~ S + I + R, level = 3)
   node time  prevalence
1     1    1 0.000000000
2     2    1 0.009803922
3     3    1 0.000000000
4     4    1 0.019047619
5     5    1 0.000000000
6     6    1 0.027777778
7     1    2 0.000000000
8     2    2 0.009803922
9     3    2 0.000000000
10    4    2 0.019047619
11    5    2 0.000000000
12    6    2 0.027777778
13    1    3 0.000000000
14    2    3 0.009803922
15    3    3 0.000000000
16    4    3 0.019047619
17    5    3 0.000000000
18    6    3 0.018518519
19    1    4 0.000000000
20    2    4 0.009803922
21    3    4 0.000000000
22    4    4 0.019047619
23    5    4 0.000000000
24    6    4 0.009259259
25    1    5 0.000000000
26    2    5 0.009803922
27    3    5 0.000000000
28    4    5 0.009523810
29    5    5 0.000000000
30    6    5 0.009259259
31    1    6 0.000000000
32    2    6 0.009803922
33    3    6 0.000000000
34    4    6 0.009523810
35    5    6 0.000000000
36    6    6 0.009259259
37    1    7 0.000000000
38    2    7 0.009803922
39    3    7 0.000000000
40    4    7 0.009523810
41    5    7 0.000000000
42    6    7 0.000000000
43    1    8 0.000000000
44    2    8 0.009803922
45    3    8 0.000000000
46    4    8 0.009523810
47    5    8 0.000000000
48    6    8 0.000000000
49    1    9 0.000000000
50    2    9 0.009803922
51    3    9 0.000000000
52    4    9 0.019047619
53    5    9 0.000000000
54    6    9 0.000000000
55    1   10 0.000000000
56    2   10 0.009803922
57    3   10 0.000000000
58    4   10 0.019047619
59    5   10 0.000000000
60    6   10 0.000000000
> 
> ## Determine the proportion of infected individuals in each node
> ## at the time-points in 'tspan' when the number of recovered is
> ## zero.
> prevalence(result, I ~ S + I + R | R == 0, level = 3)
   node time  prevalence
1     1    1 0.000000000
2     2    1 0.009803922
3     3    1 0.000000000
4     4    1 0.019047619
5     5    1 0.000000000
6     6    1 0.027777778
7     1    2 0.000000000
8     2    2 0.009803922
9     3    2 0.000000000
10    4    2 0.019047619
11    5    2 0.000000000
12    6    2         NaN
13    1    3 0.000000000
14    2    3 0.009803922
15    3    3 0.000000000
16    4    3 0.019047619
17    5    3 0.000000000
18    6    3         NaN
19    1    4 0.000000000
20    2    4 0.009803922
21    3    4 0.000000000
22    4    4         NaN
23    5    4 0.000000000
24    6    4         NaN
25    1    5 0.000000000
26    2    5 0.009803922
27    3    5 0.000000000
28    4    5         NaN
29    5    5 0.000000000
30    6    5         NaN
31    1    6 0.000000000
32    2    6 0.009803922
33    3    6 0.000000000
34    4    6         NaN
35    5    6 0.000000000
36    6    6         NaN
37    1    7 0.000000000
38    2    7 0.009803922
39    3    7 0.000000000
40    4    7         NaN
41    5    7 0.000000000
42    6    7         NaN
43    1    8 0.000000000
44    2    8 0.009803922
45    3    8 0.000000000
46    4    8         NaN
47    5    8 0.000000000
48    6    8         NaN
49    1    9 0.000000000
50    2    9 0.009803922
51    3    9 0.000000000
52    4    9         NaN
53    5    9 0.000000000
54    6    9         NaN
55    1   10 0.000000000
56    2   10 0.009803922
57    3   10 0.000000000
58    4   10         NaN
59    5   10 0.000000000
60    6   10         NaN
> 
> 
> 
> cleanEx()
> nameEx("punchcard-set")
> ### * punchcard-set
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: punchcard<-
> ### Title: Set a template for where to record result during a simulation
> ### Aliases: punchcard<- punchcard<-,SimInf_model-method
> 
> ### ** Examples
> 
> ## For reproducibility, call the set.seed() function and specify
> ## the number of threads to use. To use all available threads,
> ## remove the set_num_threads() call.
> set.seed(123)
> set_num_threads(1)
> 
> ## Create an 'SIR' model with 6 nodes and initialize it to run over 10 days.
> u0 <- data.frame(S = 100:105, I = 1:6, R = rep(0, 6))
> model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)
> 
> ## Run the model.
> result <- run(model)
> 
> ## Display the trajectory with data for every node at each
> ## time-point in tspan.
> trajectory(result)
   node time   S  I R
1     1    1 100  1 0
2     2    1 101  2 0
3     3    1 102  3 0
4     4    1 102  5 0
5     5    1 103  6 0
6     6    1 105  6 0
7     1    2 100  1 0
8     2    2 101  2 0
9     3    2 101  4 0
10    4    2 101  5 1
11    5    2 103  6 0
12    6    2 105  6 0
13    1    3  99  2 0
14    2    3 101  2 0
15    3    3 101  4 0
16    4    3  99  6 2
17    5    3 101  8 0
18    6    3 103  7 1
19    1    4  98  3 0
20    2    4 101  2 0
21    3    4 101  4 0
22    4    4  98  6 3
23    5    4  99 10 0
24    6    4 101  8 2
25    1    5  98  3 0
26    2    5 101  2 0
27    3    5 100  5 0
28    4    5  97  6 4
29    5    5  98  9 2
30    6    5 101  6 4
31    1    6  98  2 1
32    2    6 101  2 0
33    3    6 100  5 0
34    4    6  97  5 5
35    5    6  98  8 3
36    6    6 100  7 4
37    1    7  98  2 1
38    2    7  98  5 0
39    3    7 100  5 0
40    4    7  92 10 5
41    5    7  98  7 4
42    6    7  99  8 4
43    1    8  97  3 1
44    2    8  98  5 0
45    3    8  98  6 1
46    4    8  92  8 7
47    5    8  95 10 4
48    6    8  99  8 4
49    1    9  97  3 1
50    2    9  97  6 0
51    3    9  98  4 3
52    4    9  91  9 7
53    5    9  94 10 5
54    6    9  99  7 5
55    1   10  97  3 1
56    2   10  96  6 1
57    3   10  98  4 3
58    4   10  89 11 7
59    5   10  93  9 7
60    6   10  98  8 5
> 
> ## Assume we are only interested in nodes '2' and '4' at the
> ## time-points '3' and '5'
> df <- data.frame(time = c(3, 5, 3, 5),
+                  node = c(2, 2, 4, 4),
+                  S = c(TRUE, TRUE, TRUE, TRUE),
+                  I = c(TRUE, TRUE, TRUE, TRUE),
+                  R = c(TRUE, TRUE, TRUE, TRUE))
> punchcard(model) <- df
> result <- run(model)
> trajectory(result)
  node time   S I R
1    2    3 100 3 0
2    4    3 102 5 0
3    2    5 100 3 0
4    4    5 100 6 1
> 
> ## We can also specify to record only some of the compartments in
> ## each time-step.
> df <- data.frame(time = c(3, 5, 3, 5),
+                  node = c(2, 2, 4, 4),
+                  S = c(FALSE, TRUE, TRUE, TRUE),
+                  I = c(TRUE, FALSE, TRUE, FALSE),
+                  R = c(TRUE, FALSE, TRUE, TRUE))
> punchcard(model) <- df
> result <- run(model)
> trajectory(result)
  node time  S  I  R
1    2    3 NA  4  0
2    4    3 99  7  1
3    2    5 98 NA NA
4    4    5 99 NA  3
> 
> ## A shortcut to specify to record all of the compartments in
> ## each time-step is to only inlude node and time.
> df <- data.frame(time = c(3, 5, 3, 5),
+                  node = c(2, 2, 4, 4))
> punchcard(model) <- df
> result <- run(model)
> trajectory(result)
  node time   S I R
1    2    3  97 6 0
2    4    3 103 4 0
3    2    5  96 6 1
4    4    5 101 6 0
> 
> ## It is possible to use an empty 'data.frame' to specify
> ## that no data-points should be recorded for the trajectory.
> punchcard(model) <- data.frame()
> result <- run(model)
> trajectory(result)
[1] node time S    I    R   
<0 rows> (or 0-length row.names)
> 
> ## Use 'NULL' to reset the model to record data for every node at
> ## each time-point in tspan.
> punchcard(model) <- NULL
> result <- run(model)
> trajectory(result)
   node time   S  I R
1     1    1 100  1 0
2     2    1 101  2 0
3     3    1  99  6 0
4     4    1 103  4 0
5     5    1 104  5 0
6     6    1 105  6 0
7     1    2 100  1 0
8     2    2 100  3 0
9     3    2  98  7 0
10    4    2 102  4 1
11    5    2 104  5 0
12    6    2 104  7 0
13    1    3 100  1 0
14    2    3 100  2 1
15    3    3  98  7 0
16    4    3 101  5 1
17    5    3 101  8 0
18    6    3 103  6 2
19    1    4 100  1 0
20    2    4 100  2 1
21    3    4  96  9 0
22    4    4  99  7 1
23    5    4 101  6 2
24    6    4 103  5 3
25    1    5 100  1 0
26    2    5 100  2 1
27    3    5  96  7 2
28    4    5  99  6 2
29    5    5  96 11 2
30    6    5 103  5 3
31    1    6 100  1 0
32    2    6  99  3 1
33    3    6  95  8 2
34    4    6  98  7 2
35    5    6  95 11 3
36    6    6 102  5 4
37    1    7 100  1 0
38    2    7  99  3 1
39    3    7  94  9 2
40    4    7  98  7 2
41    5    7  94 12 3
42    6    7 102  4 5
43    1    8 100  1 0
44    2    8  99  3 1
45    3    8  94  8 3
46    4    8  97  7 3
47    5    8  93 13 3
48    6    8 101  5 5
49    1    9 100  1 0
50    2    9  99  3 1
51    3    9  90 11 4
52    4    9  97  7 3
53    5    9  91 13 5
54    6    9 101  5 5
55    1   10 100  1 0
56    2   10  99  3 1
57    3   10  87 14 4
58    4   10  97  5 5
59    5   10  89 14 6
60    6   10  99  7 5
> 
> 
> 
> cleanEx()
> nameEx("run")
> ### * run
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: run
> ### Title: Run the SimInf stochastic simulation algorithm
> ### Aliases: run run,SimInf_model-method run,SEIR-method run,SIR-method
> ###   run,SIS-method run,SISe-method run,SISe3-method run,SISe3_sp-method
> ###   run,SISe_sp-method run,SimInf_abc-method
> 
> ### ** Examples
> 
> ## For reproducibility, call the set.seed() function and specify
> ## the number of threads to use. To use all available threads,
> ## remove the set_num_threads() call.
> set.seed(123)
> set_num_threads(1)
> 
> ## Create an 'SIR' model with 10 nodes and initialise
> ## it to run over 100 days.
> model <- SIR(u0 = data.frame(S = rep(99, 10),
+                              I = rep(1, 10),
+                              R = rep(0, 10)),
+              tspan = 1:100,
+              beta = 0.16,
+              gamma = 0.077)
> 
> ## Run the model and save the result.
> result <- run(model)
> 
> ## Plot the proportion of susceptible, infected and recovered
> ## individuals.
> plot(result)
> 
> 
> 
> cleanEx()
> nameEx("select_matrix-set")
> ### * select_matrix-set
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: select_matrix<-
> ### Title: Set the select matrix for a 'SimInf_model' object
> ### Aliases: select_matrix<- select_matrix<-,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an SIR model
> model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
+              tspan = 1:5, beta = 0.16, gamma = 0.077)
> 
> ## Set the select matrix
> select_matrix(model) <- matrix(c(1, 0, 0, 1, 1, 1, 0, 0, 1), nrow = 3)
> 
> ## Extract the select matrix from the model
> select_matrix(model)
3 x 3 sparse Matrix of class "dgCMatrix"
  1 2 3
S 1 1 .
I . 1 .
R . 1 1
> 
> 
> 
> cleanEx()
> nameEx("select_matrix")
> ### * select_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: select_matrix
> ### Title: Extract the select matrix from a 'SimInf_model' object
> ### Aliases: select_matrix select_matrix,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an SIR model
> model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
+              tspan = 1:5, beta = 0.16, gamma = 0.077)
> 
> ## Extract the select matrix from the model
> select_matrix(model)
3 x 4 sparse Matrix of class "dgCMatrix"
  1 2 3 4
S 1 . . 1
I . 1 . 1
R . . 1 1
> 
> 
> 
> cleanEx()
> nameEx("shift_matrix-set")
> ### * shift_matrix-set
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shift_matrix<-
> ### Title: Set the shift matrix for a 'SimInf_model' object
> ### Aliases: shift_matrix<- shift_matrix<-,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an SIR model
> model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
+              tspan = 1:5, beta = 0.16, gamma = 0.077)
> 
> ## Set the shift matrix
> shift_matrix(model) <- matrix(c(2, 1, 0), nrow = 3)
> 
> ## Extract the shift matrix from the model
> shift_matrix(model)
  1
S 2
I 1
R 0
> 
> 
> 
> cleanEx()
> nameEx("shift_matrix")
> ### * shift_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shift_matrix
> ### Title: Extract the shift matrix from a 'SimInf_model' object
> ### Aliases: shift_matrix shift_matrix,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an SIR model
> model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
+              tspan = 1:5, beta = 0.16, gamma = 0.077)
> 
> ## Extract the shift matrix from the model
> shift_matrix(model)
<0 x 0 matrix>
> 
> 
> 
> cleanEx()
> nameEx("show-SimInf_model-method")
> ### * show-SimInf_model-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: show,SimInf_model-method
> ### Title: Brief summary of 'SimInf_model'
> ### Aliases: show,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an 'SIR' model with 10 nodes and initialise
> ## it to run over 100 days.
> model <- SIR(u0 = data.frame(S = rep(99, 10),
+                              I = rep(1, 10),
+                              R = rep(0, 10)),
+              tspan = 1:100,
+              beta = 0.16,
+              gamma = 0.077)
> 
> ## Brief summary of the model
> model
Model: SIR
Number of nodes: 10
Number of transitions: 2
Number of scheduled events: 0

Local data
----------
 Parameter Value
 beta      0.160
 gamma     0.077

Compartments
------------
 - Empty, please run the model first
> 
> ## Run the model and save the result
> result <- run(model)
> 
> ## Brief summary of the result. Note that 'U' and 'V' are
> ## non-empty after running the model.
> result
Model: SIR
Number of nodes: 10
Number of transitions: 2
Number of scheduled events: 0

Local data
----------
 Parameter Value
 beta      0.160
 gamma     0.077

Compartments
------------
    Min. 1st Qu. Median  Mean 3rd Qu.  Max.
 S 10.00   85.00  99.00 83.35   99.00 99.00
 I  0.00    0.00   0.00  3.01    2.00 33.00
 R  0.00    1.00   1.00 13.65    3.25 89.00
> 
> 
> 
> cleanEx()
> nameEx("trajectory-SimInf_model-method")
> ### * trajectory-SimInf_model-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trajectory,SimInf_model-method
> ### Title: Extract data from a simulated trajectory
> ### Aliases: trajectory,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an 'SIR' model with 6 nodes and initialize
> ## it to run over 10 days.
> u0 <- data.frame(S = 100:105, I = 1:6, R = rep(0, 6))
> model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)
> 
> ## Run the model to generate a single stochastic trajectory.
> result <- run(model)
> 
> ## Extract the number of individuals in each compartment at the
> ## time-points in 'tspan'.
> trajectory(result)
   node time   S  I  R
1     1    1 100  1  0
2     2    1 101  2  0
3     3    1 102  3  0
4     4    1 101  6  0
5     5    1 103  6  0
6     6    1 104  6  1
7     1    2  98  1  2
8     2    2 101  1  1
9     3    2 102  3  0
10    4    2 101  5  1
11    5    2 102  7  0
12    6    2 103  6  2
13    1    3  98  1  2
14    2    3 101  1  1
15    3    3 102  2  1
16    4    3 100  6  1
17    5    3 101  7  1
18    6    3 100  9  2
19    1    4  98  1  2
20    2    4 101  1  1
21    3    4 102  2  1
22    4    4 100  4  3
23    5    4  99  9  1
24    6    4  98 11  2
25    1    5  98  1  2
26    2    5 101  1  1
27    3    5 102  2  1
28    4    5  99  5  3
29    5    5  99  8  2
30    6    5  95 14  2
31    1    6  98  1  2
32    2    6 101  1  1
33    3    6 102  2  1
34    4    6  97  5  5
35    5    6  99  7  3
36    6    6  90 18  3
37    1    7  97  2  2
38    2    7 101  1  1
39    3    7 102  2  1
40    4    7  96  5  6
41    5    7  98  8  3
42    6    7  87 19  5
43    1    8  97  1  3
44    2    8 101  1  1
45    3    8 101  2  2
46    4    8  95  6  6
47    5    8  96  8  5
48    6    8  85 17  9
49    1    9  96  2  3
50    2    9 101  1  1
51    3    9 101  2  2
52    4    9  94  7  6
53    5    9  95  9  5
54    6    9  83 19  9
55    1   10  94  2  5
56    2   10 101  1  1
57    3   10 101  2  2
58    4   10  93  7  7
59    5   10  95  9  5
60    6   10  82 17 12
> 
> ## Extract the number of recovered individuals in the first node
> ## at the time-points in 'tspan'.
> trajectory(result, compartments = "R", index = 1)
   node time R
1     1    1 0
2     1    2 2
3     1    3 2
4     1    4 2
5     1    5 2
6     1    6 2
7     1    7 2
8     1    8 3
9     1    9 3
10    1   10 5
> 
> ## Extract the number of recovered individuals in the first and
> ## third node at the time-points in 'tspan'.
> trajectory(result, compartments = "R", index = c(1, 3))
   node time R
1     1    1 0
2     3    1 0
3     1    2 2
4     3    2 0
5     1    3 2
6     3    3 1
7     1    4 2
8     3    4 1
9     1    5 2
10    3    5 1
11    1    6 2
12    3    6 1
13    1    7 2
14    3    7 1
15    1    8 3
16    3    8 2
17    1    9 3
18    3    9 2
19    1   10 5
20    3   10 2
> 
> ## Create an 'SISe' model with 6 nodes and initialize
> ## it to run over 10 days.
> u0 <- data.frame(S = 100:105, I = 1:6)
> model <- SISe(u0 = u0, tspan = 1:10, phi = rep(0, 6),
+     upsilon = 0.02, gamma = 0.1, alpha = 1, epsilon = 1.1e-5,
+     beta_t1 = 0.15, beta_t2 = 0.15, beta_t3 = 0.15, beta_t4 = 0.15,
+     end_t1 = 91, end_t2 = 182, end_t3 = 273, end_t4 = 365)
> 
> ## Run the model
> result <- run(model)
> 
> ## Extract the continuous state variable 'phi' which represents
> ## the environmental infectious pressure.
> trajectory(result, "phi")
   node time        phi
1     1    1 0.00991199
2     2    1 0.01942848
3     3    1 0.02858243
4     4    1 0.03739418
5     5    1 0.04588256
6     6    1 0.05406505
7     1    2 0.01833718
8     2    2 0.03594268
9     3    2 0.05287749
10    4    2 0.07852502
11    5    2 0.08488274
12    6    2 0.10002035
13    1    3 0.02549859
14    2    3 0.04997975
15    3    3 0.07352830
16    4    3 0.12283204
17    5    3 0.11803288
18    6    3 0.13908235
19    1    4 0.03158580
20    2    4 0.06191127
21    3    4 0.08155767
22    4    4 0.16049300
23    5    4 0.16455914
24    6    4 0.17228505
25    1    5 0.02685893
26    2    5 0.07205305
27    3    5 0.07885883
28    4    5 0.18315902
29    5    5 0.19493214
30    6    5 0.19149834
31    1    6 0.02284109
32    2    6 0.08067357
33    3    6 0.07656482
34    4    6 0.18373355
35    5    6 0.22992350
36    6    6 0.20782963
37    1    7 0.01942592
38    2    7 0.08800101
39    3    7 0.07461490
40    4    7 0.19356769
41    5    7 0.25966616
42    6    7 0.21270222
43    1    8 0.01652304
44    2    8 0.09422933
45    3    8 0.07295748
46    4    8 0.19258092
47    5    8 0.29412173
48    6    8 0.21684393
49    1    9 0.01405558
50    2    9 0.09952341
51    3    9 0.07154866
52    4    9 0.19174217
53    5    9 0.31423465
54    6    9 0.22036437
55    1   10 0.01195824
56    2   10 0.10402337
57    3   10 0.07035117
58    4   10 0.19102923
59    5   10 0.32215633
60    6   10 0.23236576
> 
> 
> 
> cleanEx()
> nameEx("u0-set")
> ### * u0-set
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: u0<-
> ### Title: Update the initial compartment state u0 in each node
> ### Aliases: u0<- u0<-,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an SIR model object.
> model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
+              tspan = 1:100,
+              beta = 0.16,
+              gamma = 0.077)
> 
> ## Run the SIR model and plot the result.
> set.seed(22)
> result <- run(model)
> plot(result)
> 
> ## Update u0 and run the model again
> u0(model) <- data.frame(S = 990, I = 10, R = 0)
> result <- run(model)
> plot(result)
> 
> 
> 
> cleanEx()
> nameEx("u0")
> ### * u0
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: u0
> ### Title: Get the initial compartment state
> ### Aliases: u0 u0,SimInf_model-method u0,SimInf_indiv_events-method
> 
> ### ** Examples
> 
> ## Create an SIR model object.
> model <- SIR(u0 = data.frame(S = 99, I = 1, R = 0),
+              tspan = 1:100,
+              beta = 0.16,
+              gamma = 0.077)
> 
> ## Get the initial compartment state.
> u0(model)
   S I R
1 99 1 0
> 
> 
> 
> cleanEx()
> nameEx("u0_SEIR")
> ### * u0_SEIR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: u0_SEIR
> ### Title: Example data to initialize the 'SEIR' model
> ### Aliases: u0_SEIR
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## For reproducibility, call the set.seed() function and specify
> ##D ## the number of threads to use. To use all available threads,
> ##D ## remove the set_num_threads() call.
> ##D set.seed(123)
> ##D set_num_threads(1)
> ##D 
> ##D ## Create an 'SEIR' model with 1600 nodes and initialize it to
> ##D ## run over 4*365 days and record data at weekly time-points.
> ##D ## Add ten infected individuals to the first node.
> ##D u0 <- u0_SEIR()
> ##D u0$I[1] <- 10
> ##D tspan <- seq(from = 1, to = 4*365, by = 7)
> ##D model <- SEIR(u0      = u0,
> ##D               tspan   = tspan,
> ##D               events  = events_SEIR(),
> ##D               beta    = 0.16,
> ##D               epsilon = 0.25,
> ##D               gamma   = 0.01)
> ##D 
> ##D ## Run the model to generate a single stochastic trajectory.
> ##D result <- run(model)
> ##D plot(result)
> ##D 
> ##D ## Summarize trajectory
> ##D summary(result)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("u0_SIR")
> ### * u0_SIR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: u0_SIR
> ### Title: Example data to initialize the 'SIR' model
> ### Aliases: u0_SIR
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## For reproducibility, call the set.seed() function and specify
> ##D ## the number of threads to use. To use all available threads,
> ##D ## remove the set_num_threads() call.
> ##D set.seed(123)
> ##D set_num_threads(1)
> ##D 
> ##D ## Create an 'SIR' model with 1600 nodes and initialize
> ##D ## it to run over 4*365 days. Add one infected individual
> ##D ## to the first node.
> ##D u0 <- u0_SIR()
> ##D u0$I[1] <- 1
> ##D tspan <- seq(from = 1, to = 4*365, by = 1)
> ##D model <- SIR(u0     = u0,
> ##D              tspan  = tspan,
> ##D              events = events_SIR(),
> ##D              beta   = 0.16,
> ##D              gamma  = 0.01)
> ##D 
> ##D ## Run the model to generate a single stochastic trajectory.
> ##D result <- run(model)
> ##D plot(result)
> ##D 
> ##D ## Summarize trajectory
> ##D summary(result)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("u0_SIS")
> ### * u0_SIS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: u0_SIS
> ### Title: Example data to initialize the 'SIS' model
> ### Aliases: u0_SIS
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## For reproducibility, call the set.seed() function and specify
> ##D ## the number of threads to use. To use all available threads,
> ##D ## remove the set_num_threads() call.
> ##D set.seed(123)
> ##D set_num_threads(1)
> ##D 
> ##D ## Create an 'SIS' model with 1600 nodes and initialize
> ##D ## it to run over 4*365 days. Add one infected individual
> ##D ## to the first node.
> ##D u0 <- u0_SIS()
> ##D u0$I[1] <- 1
> ##D tspan <- seq(from = 1, to = 4*365, by = 1)
> ##D model <- SIS(u0     = u0,
> ##D              tspan  = tspan,
> ##D              events = events_SIS(),
> ##D              beta   = 0.16,
> ##D              gamma  = 0.01)
> ##D 
> ##D ## Run the model to generate a single stochastic trajectory.
> ##D result <- run(model)
> ##D plot(result)
> ##D 
> ##D ## Summarize trajectory
> ##D summary(result)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("u0_SISe")
> ### * u0_SISe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: u0_SISe
> ### Title: Example data to initialize the 'SISe' model
> ### Aliases: u0_SISe
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## For reproducibility, call the set.seed() function and specify
> ##D ## the number of threads to use. To use all available threads,
> ##D ## remove the set_num_threads() call.
> ##D set.seed(123)
> ##D set_num_threads(1)
> ##D 
> ##D ## Create an 'SISe' model with 1600 nodes and initialize it to
> ##D ## run over 4*365 days and record data at weekly time-points.
> ##D 
> ##D ## Load the initial population and add ten infected individuals to
> ##D ## the first node.
> ##D u0 <- u0_SISe()
> ##D u0$I[1] <- 10
> ##D 
> ##D ## Define 'tspan' to run the simulation over 4*365 and record the
> ##D ## state of the system at weekly time-points.
> ##D tspan <- seq(from = 1, to = 4*365, by = 7)
> ##D 
> ##D ## Load scheduled events for the population of nodes with births,
> ##D ## deaths and between-node movements of individuals.
> ##D events <- events_SISe()
> ##D 
> ##D ## Create an 'SISe' model
> ##D model <- SISe(u0 = u0, tspan = tspan, events = events_SISe(),
> ##D               phi = 0, upsilon = 1.8e-2, gamma = 0.1, alpha = 1,
> ##D               beta_t1 = 1.0e-1, beta_t2 = 1.0e-1, beta_t3 = 1.25e-1,
> ##D               beta_t4 = 1.25e-1, end_t1 = 91, end_t2 = 182,
> ##D               end_t3 = 273, end_t4 = 365, epsilon = 0)
> ##D 
> ##D ## Run the model to generate a single stochastic trajectory.
> ##D result <- run(model)
> ##D 
> ##D ## Summarize trajectory
> ##D summary(result)
> ##D 
> ##D ## Plot the proportion of nodes with at least one infected
> ##D ## individual.
> ##D plot(result, I~S+I, level = 2, type = "l")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("u0_SISe3")
> ### * u0_SISe3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: u0_SISe3
> ### Title: Example data to initialize the 'SISe3' model
> ### Aliases: u0_SISe3
> ### Keywords: dataset
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## For reproducibility, call the set.seed() function and specify
> ##D ## the number of threads to use. To use all available threads,
> ##D ## remove the set_num_threads() call.
> ##D set.seed(123)
> ##D set_num_threads(1)
> ##D 
> ##D ## Create an 'SISe3' model with 1600 nodes and initialize it to
> ##D ## run over 4*365 days and record data at weekly time-points.
> ##D 
> ##D ## Load the initial population and add ten infected individuals to
> ##D ## I_1 in the first node.
> ##D u0 <- u0_SISe3
> ##D u0$I_1[1] <- 10
> ##D 
> ##D ## Define 'tspan' to run the simulation over 4*365 and record the
> ##D ## state of the system at weekly time-points.
> ##D tspan <- seq(from = 1, to = 4*365, by = 7)
> ##D 
> ##D ## Load scheduled events for the population of nodes with births,
> ##D ## deaths and between-node movements of individuals.
> ##D events <- events_SISe3
> ##D 
> ##D ## Create a 'SISe3' model
> ##D model <- SISe3(u0 = u0, tspan = tspan, events = events,
> ##D                phi = rep(0, nrow(u0)), upsilon_1 = 1.8e-2,
> ##D                upsilon_2 = 1.8e-2, upsilon_3 = 1.8e-2,
> ##D                gamma_1 = 0.1, gamma_2 = 0.1, gamma_3 = 0.1,
> ##D                alpha = 1, beta_t1 = 1.0e-1, beta_t2 = 1.0e-1,
> ##D                beta_t3 = 1.25e-1, beta_t4 = 1.25e-1, end_t1 = 91,
> ##D                end_t2 = 182, end_t3 = 273, end_t4 = 365, epsilon = 0)
> ##D 
> ##D ## Run the model to generate a single stochastic trajectory.
> ##D result <- run(model)
> ##D 
> ##D ## Summarize trajectory
> ##D summary(result)
> ##D 
> ##D ## Plot the proportion of nodes with at least one infected
> ##D ## individual.
> ##D plot(result, I_1 + I_2 + I_3 ~ ., level = 2, type = "l")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("v0-set")
> ### * v0-set
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: v0<-
> ### Title: Update the initial continuous state v0 in each node
> ### Aliases: v0<- v0<-,SimInf_model-method
> 
> ### ** Examples
> 
> ## Create an 'SISe' model with no infected individuals and no
> ## infectious pressure (phi = 0, epsilon = 0).
> model <- SISe(u0 = data.frame(S = 100, I = 0), tspan = 1:100,
+               phi = 0, upsilon = 0.02, gamma = 0.1, alpha = 1,
+               epsilon = 0, beta_t1 = 0.15, beta_t2 = 0.15,
+               beta_t3 = 0.15, beta_t4 = 0.15, end_t1 = 91,
+               end_t2 = 182, end_t3 = 273, end_t4 = 365)
> 
> ## Run the 'SISe' model and plot the result.
> set.seed(22)
> result <- run(model)
> plot(result)
> 
> ## Update the infectious pressure 'phi' in 'v0' and run
> ## the model again.
> v0(model) <- data.frame(phi = 1)
> result <- run(model)
> plot(result)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  11.053 0.562 11.576 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
